{"version":3,"file":"Sender.js.map","sources":["Sender.js"],"sourcesContent":["import { SessionStorageSendBuffer, ArraySendBuffer } from './SendBuffer';\r\nimport { DependencyEnvelopeCreator, EventEnvelopeCreator, ExceptionEnvelopeCreator, MetricEnvelopeCreator, PageViewEnvelopeCreator, PageViewPerformanceEnvelopeCreator, TraceEnvelopeCreator } from './EnvelopeCreator';\r\nimport { Serializer } from './Serializer'; // todo move to channel\r\nimport { DisabledPropertyName, RequestHeaders, Util, PageView, Event, Trace, Exception, Metric, PageViewPerformance, RemoteDependencyData, ProcessLegacy, BreezeChannelIdentifier, SampleRate } from '@microsoft/applicationinsights-common';\r\nimport { CoreUtils, _InternalMessageId, LoggingSeverity, getWindow, getNavigator, getJSON, BaseTelemetryPlugin, getGlobalInst, objForEachKey } from '@microsoft/applicationinsights-core-js';\r\nimport { Offline } from './Offline';\r\nimport { Sample } from './TelemetryProcessors/Sample';\r\nimport dynamicProto from '@microsoft/dynamicproto-js';\r\nfunction _getResponseText(xhr) {\r\n    try {\r\n        return xhr.responseText;\r\n    }\r\n    catch (e) {\r\n        // Best effort, as XHR may throw while XDR wont so just ignore\r\n    }\r\n    return null;\r\n}\r\nvar Sender = /** @class */ (function (_super) {\r\n    __extends(Sender, _super);\r\n    function Sender() {\r\n        var _this = _super.call(this) || this;\r\n        _this.priority = 1001;\r\n        _this.identifier = BreezeChannelIdentifier;\r\n        /**\r\n         * Whether XMLHttpRequest object is supported. Older version of IE (8,9) do not support it.\r\n         */\r\n        _this._XMLHttpRequestSupported = false;\r\n        /**\r\n         * How many times in a row a retryable error condition has occurred.\r\n         */\r\n        var _consecutiveErrors;\r\n        /**\r\n         * The time to retry at in milliseconds from 1970/01/01 (this makes the timer calculation easy).\r\n         */\r\n        var _retryAt;\r\n        /**\r\n         * The time of the last send operation.\r\n         */\r\n        var _lastSend;\r\n        /**\r\n         * Handle to the timer for delayed sending of batches of data.\r\n         */\r\n        var _timeoutHandle;\r\n        var _serializer;\r\n        dynamicProto(Sender, _this, function (_self, _base) {\r\n            function _notImplemented() {\r\n                throw new Error(\"Method not implemented.\");\r\n            }\r\n            _self.pause = _notImplemented;\r\n            _self.resume = _notImplemented;\r\n            _self.flush = function () {\r\n                try {\r\n                    _self.triggerSend(true, null, 1 /* ManualFlush */);\r\n                }\r\n                catch (e) {\r\n                    _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FlushFailed, \"flush failed, telemetry will not be collected: \" + Util.getExceptionName(e), { exception: Util.dump(e) });\r\n                }\r\n            };\r\n            _self.onunloadFlush = function () {\r\n                if ((_self._senderConfig.onunloadDisableBeacon() === false || _self._senderConfig.isBeaconApiDisabled() === false) && Util.IsBeaconApiSupported()) {\r\n                    try {\r\n                        _self.triggerSend(true, _beaconSender, 2 /* Unload */);\r\n                    }\r\n                    catch (e) {\r\n                        _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedToSendQueuedTelemetry, \"failed to flush with beacon sender on page unload, telemetry will not be collected: \" + Util.getExceptionName(e), { exception: Util.dump(e) });\r\n                    }\r\n                }\r\n                else {\r\n                    _self.flush();\r\n                }\r\n            };\r\n            _self.teardown = _notImplemented;\r\n            _self.initialize = function (config, core, extensions, pluginChain) {\r\n                _base.initialize(config, core, extensions, pluginChain);\r\n                var ctx = _self._getTelCtx();\r\n                var identifier = _self.identifier;\r\n                _serializer = new Serializer(core.logger);\r\n                _consecutiveErrors = 0;\r\n                _retryAt = null;\r\n                _lastSend = 0;\r\n                _self._sender = null;\r\n                var defaultConfig = Sender._getDefaultAppInsightsChannelConfig();\r\n                _self._senderConfig = Sender._getEmptyAppInsightsChannelConfig();\r\n                objForEachKey(defaultConfig, function (field, value) {\r\n                    _self._senderConfig[field] = function () { return ctx.getConfig(identifier, field, value()); };\r\n                });\r\n                _self._buffer = (_self._senderConfig.enableSessionStorageBuffer() && Util.canUseSessionStorage())\r\n                    ? new SessionStorageSendBuffer(_self.diagLog(), _self._senderConfig) : new ArraySendBuffer(_self._senderConfig);\r\n                _self._sample = new Sample(_self._senderConfig.samplingPercentage(), _self.diagLog());\r\n                if (!_validateInstrumentationKey(config)) {\r\n                    _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.InvalidInstrumentationKey, \"Invalid Instrumentation key \" + config.instrumentationKey);\r\n                }\r\n                if (!_self._senderConfig.isBeaconApiDisabled() && Util.IsBeaconApiSupported()) {\r\n                    _self._sender = _beaconSender;\r\n                }\r\n                else {\r\n                    if (typeof XMLHttpRequest !== undefined) {\r\n                        var xhr = getGlobalInst(\"XMLHttpRequest\");\r\n                        if (xhr) {\r\n                            var testXhr = new xhr();\r\n                            if (\"withCredentials\" in testXhr) {\r\n                                _self._sender = _xhrSender;\r\n                                _self._XMLHttpRequestSupported = true;\r\n                            }\r\n                            else if (typeof XDomainRequest !== undefined) {\r\n                                _self._sender = _xdrSender; // IE 8 and 9\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            _self.processTelemetry = function (telemetryItem, itemCtx) {\r\n                itemCtx = _self._getTelCtx(itemCtx);\r\n                try {\r\n                    // if master off switch is set, don't send any data\r\n                    if (_self._senderConfig.disableTelemetry()) {\r\n                        // Do not send/save data\r\n                        return;\r\n                    }\r\n                    // validate input\r\n                    if (!telemetryItem) {\r\n                        itemCtx.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.CannotSendEmptyTelemetry, \"Cannot send empty telemetry\");\r\n                        return;\r\n                    }\r\n                    // validate event\r\n                    if (telemetryItem.baseData && !telemetryItem.baseType) {\r\n                        itemCtx.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.InvalidEvent, \"Cannot send telemetry without baseData and baseType\");\r\n                        return;\r\n                    }\r\n                    if (!telemetryItem.baseType) {\r\n                        // Default\r\n                        telemetryItem.baseType = \"EventData\";\r\n                    }\r\n                    // ensure a sender was constructed\r\n                    if (!_self._sender) {\r\n                        itemCtx.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.SenderNotInitialized, \"Sender was not initialized\");\r\n                        return;\r\n                    }\r\n                    // check if this item should be sampled in, else add sampleRate tag\r\n                    if (!_isSampledIn(telemetryItem)) {\r\n                        // Item is sampled out, do not send it\r\n                        itemCtx.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TelemetrySampledAndNotSent, \"Telemetry item was sampled out and not sent\", { SampleRate: _self._sample.sampleRate });\r\n                        return;\r\n                    }\r\n                    else {\r\n                        telemetryItem[SampleRate] = _self._sample.sampleRate;\r\n                    }\r\n                    // construct an envelope that Application Insights endpoint can understand\r\n                    var aiEnvelope_1 = Sender.constructEnvelope(telemetryItem, _self._senderConfig.instrumentationKey(), itemCtx.diagLog());\r\n                    if (!aiEnvelope_1) {\r\n                        itemCtx.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.CreateEnvelopeError, \"Unable to create an AppInsights envelope\");\r\n                        return;\r\n                    }\r\n                    var doNotSendItem_1 = false;\r\n                    // this is for running in legacy mode, where customer may already have a custom initializer present\r\n                    if (telemetryItem.tags && telemetryItem.tags[ProcessLegacy]) {\r\n                        CoreUtils.arrForEach(telemetryItem.tags[ProcessLegacy], function (callBack) {\r\n                            try {\r\n                                if (callBack && callBack(aiEnvelope_1) === false) {\r\n                                    doNotSendItem_1 = true;\r\n                                    itemCtx.diagLog().warnToConsole(\"Telemetry processor check returns false\");\r\n                                }\r\n                            }\r\n                            catch (e) {\r\n                                // log error but dont stop executing rest of the telemetry initializers\r\n                                // doNotSendItem = true;\r\n                                itemCtx.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TelemetryInitializerFailed, \"One of telemetry initializers failed, telemetry item will not be sent: \" + Util.getExceptionName(e), { exception: Util.dump(e) }, true);\r\n                            }\r\n                        });\r\n                        delete telemetryItem.tags[ProcessLegacy];\r\n                    }\r\n                    if (doNotSendItem_1) {\r\n                        return; // do not send, no need to execute next plugin\r\n                    }\r\n                    // check if the incoming payload is too large, truncate if necessary\r\n                    var payload = _serializer.serialize(aiEnvelope_1);\r\n                    // flush if we would exceed the max-size limit by adding this item\r\n                    var bufferPayload = _self._buffer.getItems();\r\n                    var batch = _self._buffer.batchPayloads(bufferPayload);\r\n                    if (batch && (batch.length + payload.length > _self._senderConfig.maxBatchSizeInBytes())) {\r\n                        _self.triggerSend(true, null, 10 /* MaxBatchSize */);\r\n                    }\r\n                    // enqueue the payload\r\n                    _self._buffer.enqueue(payload);\r\n                    // ensure an invocation timeout is set\r\n                    _setupTimer();\r\n                }\r\n                catch (e) {\r\n                    itemCtx.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedAddingTelemetryToBuffer, \"Failed adding telemetry to the sender's buffer, some telemetry will be lost: \" + Util.getExceptionName(e), { exception: Util.dump(e) });\r\n                }\r\n                // hand off the telemetry item to the next plugin\r\n                _self.processNext(telemetryItem, itemCtx);\r\n            };\r\n            /**\r\n             * xhr state changes\r\n             */\r\n            _self._xhrReadyStateChange = function (xhr, payload, countOfItemsInPayload) {\r\n                if (xhr.readyState === 4) {\r\n                    var response = null;\r\n                    if (!_self._appId) {\r\n                        response = _parseResponse(_getResponseText(xhr) || xhr.response);\r\n                        if (response && response.appId) {\r\n                            _self._appId = response.appId;\r\n                        }\r\n                    }\r\n                    if ((xhr.status < 200 || xhr.status >= 300) && xhr.status !== 0) {\r\n                        if (!_self._senderConfig.isRetryDisabled() && _isRetriable(xhr.status)) {\r\n                            _resendPayload(payload);\r\n                            _self.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TransmissionFailed, \". \" +\r\n                                \"Response code \" + xhr.status + \". Will retry to send \" + payload.length + \" items.\");\r\n                        }\r\n                        else {\r\n                            _self._onError(payload, _formatErrorMessageXhr(xhr));\r\n                        }\r\n                    }\r\n                    else if (Offline.isOffline()) {\r\n                        // Note: Don't check for status == 0, since adblock gives this code\r\n                        if (!_self._senderConfig.isRetryDisabled()) {\r\n                            var offlineBackOffMultiplier = 10; // arbritrary number\r\n                            _resendPayload(payload, offlineBackOffMultiplier);\r\n                            _self.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TransmissionFailed, \". Offline - Response Code: \" + xhr.status + \". Offline status: \" + Offline.isOffline() + \". Will retry to send \" + payload.length + \" items.\");\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (xhr.status === 206) {\r\n                            if (!response) {\r\n                                response = _parseResponse(_getResponseText(xhr) || xhr.response);\r\n                            }\r\n                            if (response && !_self._senderConfig.isRetryDisabled()) {\r\n                                _self._onPartialSuccess(payload, response);\r\n                            }\r\n                            else {\r\n                                _self._onError(payload, _formatErrorMessageXhr(xhr));\r\n                            }\r\n                        }\r\n                        else {\r\n                            _consecutiveErrors = 0;\r\n                            _self._onSuccess(payload, countOfItemsInPayload);\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            /**\r\n             * Immediately send buffered data\r\n             * @param async {boolean} - Indicates if the events should be sent asynchronously\r\n             * @param forcedSender {SenderFunction} - Indicates the forcedSender, undefined if not passed\r\n             */\r\n            _self.triggerSend = function (async, forcedSender, sendReason) {\r\n                if (async === void 0) { async = true; }\r\n                try {\r\n                    // Send data only if disableTelemetry is false\r\n                    if (!_self._senderConfig.disableTelemetry()) {\r\n                        if (_self._buffer.count() > 0) {\r\n                            var payload = _self._buffer.getItems();\r\n                            _notifySendRequest(sendReason || 0 /* Undefined */, async);\r\n                            // invoke send\r\n                            if (forcedSender) {\r\n                                forcedSender.call(_this, payload, async);\r\n                            }\r\n                            else {\r\n                                _self._sender(payload, async);\r\n                            }\r\n                        }\r\n                        // update lastSend time to enable throttling\r\n                        _lastSend = +new Date;\r\n                    }\r\n                    else {\r\n                        _self._buffer.clear();\r\n                    }\r\n                    clearTimeout(_timeoutHandle);\r\n                    _timeoutHandle = null;\r\n                    _retryAt = null;\r\n                }\r\n                catch (e) {\r\n                    /* Ignore this error for IE under v10 */\r\n                    var ieVer = Util.getIEVersion();\r\n                    if (!ieVer || ieVer > 9) {\r\n                        _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TransmissionFailed, \"Telemetry transmission failed, some telemetry will be lost: \" + Util.getExceptionName(e), { exception: Util.dump(e) });\r\n                    }\r\n                }\r\n            };\r\n            /**\r\n             * error handler\r\n             */\r\n            _self._onError = function (payload, message, event) {\r\n                _self.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.OnError, \"Failed to send telemetry.\", { message: message });\r\n                _self._buffer.clearSent(payload);\r\n            };\r\n            /**\r\n             * partial success handler\r\n             */\r\n            _self._onPartialSuccess = function (payload, results) {\r\n                var failed = [];\r\n                var retry = [];\r\n                // Iterate through the reversed array of errors so that splicing doesn't have invalid indexes after the first item.\r\n                var errors = results.errors.reverse();\r\n                for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\r\n                    var error = errors_1[_i];\r\n                    var extracted = payload.splice(error.index, 1)[0];\r\n                    if (_isRetriable(error.statusCode)) {\r\n                        retry.push(extracted);\r\n                    }\r\n                    else {\r\n                        // All other errors, including: 402 (Monthly quota exceeded) and 439 (Too many requests and refresh cache).\r\n                        failed.push(extracted);\r\n                    }\r\n                }\r\n                if (payload.length > 0) {\r\n                    _self._onSuccess(payload, results.itemsAccepted);\r\n                }\r\n                if (failed.length > 0) {\r\n                    _self._onError(failed, _formatErrorMessageXhr(null, ['partial success', results.itemsAccepted, 'of', results.itemsReceived].join(' ')));\r\n                }\r\n                if (retry.length > 0) {\r\n                    _resendPayload(retry);\r\n                    _self.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TransmissionFailed, \"Partial success. \" +\r\n                        \"Delivered: \" + payload.length + \", Failed: \" + failed.length +\r\n                        \". Will retry to send \" + retry.length + \" our of \" + results.itemsReceived + \" items\");\r\n                }\r\n            };\r\n            /**\r\n             * success handler\r\n             */\r\n            _self._onSuccess = function (payload, countOfItemsInPayload) {\r\n                _self._buffer.clearSent(payload);\r\n            };\r\n            /**\r\n             * xdr state changes\r\n             */\r\n            _self._xdrOnLoad = function (xdr, payload) {\r\n                var responseText = _getResponseText(xdr);\r\n                if (xdr && (responseText + \"\" === \"200\" || responseText === \"\")) {\r\n                    _consecutiveErrors = 0;\r\n                    _self._onSuccess(payload, 0);\r\n                }\r\n                else {\r\n                    var results = _parseResponse(responseText);\r\n                    if (results && results.itemsReceived && results.itemsReceived > results.itemsAccepted\r\n                        && !_self._senderConfig.isRetryDisabled()) {\r\n                        _self._onPartialSuccess(payload, results);\r\n                    }\r\n                    else {\r\n                        _self._onError(payload, _formatErrorMessageXdr(xdr));\r\n                    }\r\n                }\r\n            };\r\n            function _isSampledIn(envelope) {\r\n                return _self._sample.isSampledIn(envelope);\r\n            }\r\n            /**\r\n             * Send Beacon API request\r\n             * @param payload {string} - The data payload to be sent.\r\n             * @param isAsync {boolean} - not used\r\n             * Note: Beacon API does not support custom headers and we are not able to get\r\n             * appId from the backend for the correct correlation.\r\n             */\r\n            function _beaconSender(payload, isAsync) {\r\n                var url = _self._senderConfig.endpointUrl();\r\n                var batch = _self._buffer.batchPayloads(payload);\r\n                // Chrome only allows CORS-safelisted values for the sendBeacon data argument\r\n                // see: https://bugs.chromium.org/p/chromium/issues/detail?id=720283\r\n                var plainTextBatch = new Blob([batch], { type: 'text/plain;charset=UTF-8' });\r\n                // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.\r\n                var queued = getNavigator().sendBeacon(url, plainTextBatch);\r\n                if (queued) {\r\n                    _self._buffer.markAsSent(payload);\r\n                    // no response from beaconSender, clear buffer\r\n                    _self._onSuccess(payload, payload.length);\r\n                }\r\n                else {\r\n                    _xhrSender(payload, true);\r\n                    _self.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TransmissionFailed, \". \" + \"Failed to send telemetry with Beacon API, retried with xhrSender.\");\r\n                }\r\n            }\r\n            /**\r\n             * Send XMLHttpRequest\r\n             * @param payload {string} - The data payload to be sent.\r\n             * @param isAsync {boolean} - Indicates if the request should be sent asynchronously\r\n             */\r\n            function _xhrSender(payload, isAsync) {\r\n                var xhr = new XMLHttpRequest();\r\n                var endPointUrl = _self._senderConfig.endpointUrl();\r\n                try {\r\n                    xhr[DisabledPropertyName] = true;\r\n                }\r\n                catch (e) {\r\n                    // If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would\r\n                    // cause the request to fail and we no telemetry would be sent\r\n                }\r\n                xhr.open(\"POST\", endPointUrl, isAsync);\r\n                xhr.setRequestHeader(\"Content-type\", \"application/json\");\r\n                // append Sdk-Context request header only in case of breeze endpoint\r\n                if (Util.isInternalApplicationInsightsEndpoint(endPointUrl)) {\r\n                    xhr.setRequestHeader(RequestHeaders.sdkContextHeader, RequestHeaders.sdkContextHeaderAppIdRequest);\r\n                }\r\n                xhr.onreadystatechange = function () { return _self._xhrReadyStateChange(xhr, payload, payload.length); };\r\n                xhr.onerror = function (event) { return _self._onError(payload, _formatErrorMessageXhr(xhr), event); };\r\n                // compose an array of payloads\r\n                var batch = _self._buffer.batchPayloads(payload);\r\n                xhr.send(batch);\r\n                _self._buffer.markAsSent(payload);\r\n            }\r\n            /**\r\n             * Parses the response from the backend.\r\n             * @param response - XMLHttpRequest or XDomainRequest response\r\n             */\r\n            function _parseResponse(response) {\r\n                try {\r\n                    if (response && response !== \"\") {\r\n                        var result = getJSON().parse(response);\r\n                        if (result && result.itemsReceived && result.itemsReceived >= result.itemsAccepted &&\r\n                            result.itemsReceived - result.itemsAccepted === result.errors.length) {\r\n                            return result;\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.InvalidBackendResponse, \"Cannot parse the response. \" + Util.getExceptionName(e), {\r\n                        response: response\r\n                    });\r\n                }\r\n                return null;\r\n            }\r\n            /**\r\n             * Resend payload. Adds payload back to the send buffer and setup a send timer (with exponential backoff).\r\n             * @param payload\r\n             */\r\n            function _resendPayload(payload, linearFactor) {\r\n                if (linearFactor === void 0) { linearFactor = 1; }\r\n                if (!payload || payload.length === 0) {\r\n                    return;\r\n                }\r\n                _self._buffer.clearSent(payload);\r\n                _consecutiveErrors++;\r\n                for (var _i = 0, payload_1 = payload; _i < payload_1.length; _i++) {\r\n                    var item = payload_1[_i];\r\n                    _self._buffer.enqueue(item);\r\n                }\r\n                // setup timer\r\n                _setRetryTime(linearFactor);\r\n                _setupTimer();\r\n            }\r\n            /**\r\n             * Calculates the time to wait before retrying in case of an error based on\r\n             * http://en.wikipedia.org/wiki/Exponential_backoff\r\n             */\r\n            function _setRetryTime(linearFactor) {\r\n                var SlotDelayInSeconds = 10;\r\n                var delayInSeconds;\r\n                if (_consecutiveErrors <= 1) {\r\n                    delayInSeconds = SlotDelayInSeconds;\r\n                }\r\n                else {\r\n                    var backOffSlot = (Math.pow(2, _consecutiveErrors) - 1) / 2;\r\n                    // tslint:disable-next-line:insecure-random\r\n                    var backOffDelay = Math.floor(Math.random() * backOffSlot * SlotDelayInSeconds) + 1;\r\n                    backOffDelay = linearFactor * backOffDelay;\r\n                    delayInSeconds = Math.max(Math.min(backOffDelay, 3600), SlotDelayInSeconds);\r\n                }\r\n                // TODO: Log the backoff time like the C# version does.\r\n                var retryAfterTimeSpan = CoreUtils.dateNow() + (delayInSeconds * 1000);\r\n                // TODO: Log the retry at time like the C# version does.\r\n                _retryAt = retryAfterTimeSpan;\r\n            }\r\n            /**\r\n             * Sets up the timer which triggers actually sending the data.\r\n             */\r\n            function _setupTimer() {\r\n                if (!_timeoutHandle) {\r\n                    var retryInterval = _retryAt ? Math.max(0, _retryAt - CoreUtils.dateNow()) : 0;\r\n                    var timerValue = Math.max(_self._senderConfig.maxBatchInterval(), retryInterval);\r\n                    _timeoutHandle = setTimeout(function () {\r\n                        _self.triggerSend(true, null, 1 /* NormalSchedule */);\r\n                    }, timerValue);\r\n                }\r\n            }\r\n            /**\r\n             * Checks if the SDK should resend the payload after receiving this status code from the backend.\r\n             * @param statusCode\r\n             */\r\n            function _isRetriable(statusCode) {\r\n                return statusCode === 408 // Timeout\r\n                    || statusCode === 429 // Too many requests.\r\n                    || statusCode === 500 // Internal server error.\r\n                    || statusCode === 503; // Service unavailable.\r\n            }\r\n            function _formatErrorMessageXhr(xhr, message) {\r\n                if (xhr) {\r\n                    return \"XMLHttpRequest,Status:\" + xhr.status + \",Response:\" + _getResponseText(xhr) || xhr.response || \"\";\r\n                }\r\n                return message;\r\n            }\r\n            /**\r\n             * Send XDomainRequest\r\n             * @param payload {string} - The data payload to be sent.\r\n             * @param isAsync {boolean} - Indicates if the request should be sent asynchronously\r\n             *\r\n             * Note: XDomainRequest does not support sync requests. This 'isAsync' parameter is added\r\n             * to maintain consistency with the xhrSender's contract\r\n             * Note: XDomainRequest does not support custom headers and we are not able to get\r\n             * appId from the backend for the correct correlation.\r\n             */\r\n            function _xdrSender(payload, isAsync) {\r\n                var _window = getWindow();\r\n                var xdr = new XDomainRequest();\r\n                xdr.onload = function () { return _self._xdrOnLoad(xdr, payload); };\r\n                xdr.onerror = function (event) { return _self._onError(payload, _formatErrorMessageXdr(xdr), event); };\r\n                // XDomainRequest requires the same protocol as the hosting page.\r\n                // If the protocol doesn't match, we can't send the telemetry :(.\r\n                var hostingProtocol = _window && _window.location && _window.location.protocol || \"\";\r\n                if (_self._senderConfig.endpointUrl().lastIndexOf(hostingProtocol, 0) !== 0) {\r\n                    _self.diagLog().throwInternal(LoggingSeverity.WARNING, _InternalMessageId.TransmissionFailed, \". \" +\r\n                        \"Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.\");\r\n                    _self._buffer.clear();\r\n                    return;\r\n                }\r\n                var endpointUrl = _self._senderConfig.endpointUrl().replace(/^(https?:)/, \"\");\r\n                xdr.open('POST', endpointUrl);\r\n                // compose an array of payloads\r\n                var batch = _self._buffer.batchPayloads(payload);\r\n                xdr.send(batch);\r\n                _self._buffer.markAsSent(payload);\r\n            }\r\n            function _formatErrorMessageXdr(xdr, message) {\r\n                if (xdr) {\r\n                    return \"XDomainRequest,Response:\" + _getResponseText(xdr) || \"\";\r\n                }\r\n                return message;\r\n            }\r\n            // Using function lookups for backward compatibility as the getNotifyMgr() did not exist until after v2.5.6\r\n            function _getNotifyMgr() {\r\n                var func = 'getNotifyMgr';\r\n                if (_self.core[func]) {\r\n                    return _self.core[func]();\r\n                }\r\n                // using _self.core['_notificationManager'] for backward compatibility\r\n                return _self.core['_notificationManager'];\r\n            }\r\n            function _notifySendRequest(sendRequest, isAsync) {\r\n                var manager = _getNotifyMgr();\r\n                if (manager && manager.eventsSendRequest) {\r\n                    try {\r\n                        manager.eventsSendRequest(sendRequest, isAsync);\r\n                    }\r\n                    catch (e) {\r\n                        _self.diagLog().throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.NotificationException, \"send request notification failed: \" + Util.getExceptionName(e), { exception: Util.dump(e) });\r\n                    }\r\n                }\r\n            }\r\n            /**\r\n             * Validate UUID Format\r\n             * Specs taken from https://tools.ietf.org/html/rfc4122 and breeze repo\r\n             */\r\n            function _validateInstrumentationKey(config) {\r\n                var disableIKeyValidationFlag = CoreUtils.isNullOrUndefined(config.disableInstrumentationKeyValidation) ? false : config.disableInstrumentationKeyValidation;\r\n                if (disableIKeyValidationFlag) {\r\n                    return true;\r\n                }\r\n                var UUID_Regex = '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$';\r\n                var regexp = new RegExp(UUID_Regex);\r\n                return regexp.test(config.instrumentationKey);\r\n            }\r\n        });\r\n        return _this;\r\n    }\r\n    Sender.constructEnvelope = function (orig, iKey, logger) {\r\n        var envelope;\r\n        if (iKey !== orig.iKey && !CoreUtils.isNullOrUndefined(iKey)) {\r\n            envelope = __assign({}, orig, { iKey: iKey });\r\n        }\r\n        else {\r\n            envelope = orig;\r\n        }\r\n        switch (envelope.baseType) {\r\n            case Event.dataType:\r\n                return EventEnvelopeCreator.EventEnvelopeCreator.Create(logger, envelope);\r\n            case Trace.dataType:\r\n                return TraceEnvelopeCreator.TraceEnvelopeCreator.Create(logger, envelope);\r\n            case PageView.dataType:\r\n                return PageViewEnvelopeCreator.PageViewEnvelopeCreator.Create(logger, envelope);\r\n            case PageViewPerformance.dataType:\r\n                return PageViewPerformanceEnvelopeCreator.PageViewPerformanceEnvelopeCreator.Create(logger, envelope);\r\n            case Exception.dataType:\r\n                return ExceptionEnvelopeCreator.ExceptionEnvelopeCreator.Create(logger, envelope);\r\n            case Metric.dataType:\r\n                return MetricEnvelopeCreator.MetricEnvelopeCreator.Create(logger, envelope);\r\n            case RemoteDependencyData.dataType:\r\n                return DependencyEnvelopeCreator.DependencyEnvelopeCreator.Create(logger, envelope);\r\n            default:\r\n                return EventEnvelopeCreator.EventEnvelopeCreator.Create(logger, envelope);\r\n        }\r\n    };\r\n    Sender._getDefaultAppInsightsChannelConfig = function () {\r\n        // set default values\r\n        return {\r\n            endpointUrl: function () { return \"https://dc.services.visualstudio.com/v2/track\"; },\r\n            emitLineDelimitedJson: function () { return false; },\r\n            maxBatchInterval: function () { return 15000; },\r\n            maxBatchSizeInBytes: function () { return 102400; },\r\n            disableTelemetry: function () { return false; },\r\n            enableSessionStorageBuffer: function () { return true; },\r\n            isRetryDisabled: function () { return false; },\r\n            isBeaconApiDisabled: function () { return true; },\r\n            onunloadDisableBeacon: function () { return false; },\r\n            instrumentationKey: function () { return undefined; },\r\n            namePrefix: function () { return undefined; },\r\n            samplingPercentage: function () { return 100; }\r\n        };\r\n    };\r\n    Sender._getEmptyAppInsightsChannelConfig = function () {\r\n        return {\r\n            endpointUrl: undefined,\r\n            emitLineDelimitedJson: undefined,\r\n            maxBatchInterval: undefined,\r\n            maxBatchSizeInBytes: undefined,\r\n            disableTelemetry: undefined,\r\n            enableSessionStorageBuffer: undefined,\r\n            isRetryDisabled: undefined,\r\n            isBeaconApiDisabled: undefined,\r\n            onunloadDisableBeacon: undefined,\r\n            instrumentationKey: undefined,\r\n            namePrefix: undefined,\r\n            samplingPercentage: undefined\r\n        };\r\n    };\r\n    Sender.prototype.pause = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    Sender.prototype.resume = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    Sender.prototype.flush = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    Sender.prototype.onunloadFlush = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    Sender.prototype.teardown = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    Sender.prototype.initialize = function (config, core, extensions, pluginChain) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    Sender.prototype.processTelemetry = function (telemetryItem, itemCtx) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * xhr state changes\r\n     */\r\n    Sender.prototype._xhrReadyStateChange = function (xhr, payload, countOfItemsInPayload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Immediately send buffered data\r\n     * @param async {boolean} - Indicates if the events should be sent asynchronously\r\n     * @param forcedSender {SenderFunction} - Indicates the forcedSender, undefined if not passed\r\n     */\r\n    Sender.prototype.triggerSend = function (async, forcedSender, sendReason) {\r\n        if (async === void 0) { async = true; }\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * error handler\r\n     */\r\n    Sender.prototype._onError = function (payload, message, event) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * partial success handler\r\n     */\r\n    Sender.prototype._onPartialSuccess = function (payload, results) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * success handler\r\n     */\r\n    Sender.prototype._onSuccess = function (payload, countOfItemsInPayload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * xdr state changes\r\n     */\r\n    Sender.prototype._xdrOnLoad = function (xdr, payload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    return Sender;\r\n}(BaseTelemetryPlugin));\r\nexport { Sender };\r\n//# sourceMappingURL=Sender.js.map"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;gDA2DM;AACN;AACA;AACA;AACA"}
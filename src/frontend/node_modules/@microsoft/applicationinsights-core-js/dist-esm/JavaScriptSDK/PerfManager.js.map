{"version":3,"file":"PerfManager.js","sourceRoot":"","sources":["../../src/JavaScriptSDK/PerfManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport { INotificationManager } from '../JavaScriptSDK.Interfaces/INotificationManager';\r\nimport { IPerfEvent } from '../JavaScriptSDK.Interfaces/IPerfEvent';\r\nimport { IPerfManager, IPerfManagerProvider } from '../JavaScriptSDK.Interfaces/IPerfManager';\r\n\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { CoreUtils } from \"./CoreUtils\";\r\n\r\nconst strExecutionContextKey = \"ctx\";\r\n\r\nexport class PerfEvent implements IPerfEvent {\r\n    public static ParentContextKey = \"parent\";\r\n    public static ChildrenContextKey = \"childEvts\";\r\n    \r\n    /**\r\n     * The name of the event\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The start time of the event in ms\r\n     */\r\n    start: number;\r\n\r\n    /**\r\n     * The payload (contents) of the perfEvent, may be null or only set after the event has completed depending on\r\n     * the runtime environment.\r\n     */\r\n    payload: any;\r\n\r\n    /**\r\n     * Is this occurring from an asynchronous event\r\n     */\r\n    isAsync: boolean;\r\n    \r\n    /**\r\n     * Identifies the total inclusive time spent for this event, including the time spent for child events, \r\n     * this will be undefined until the event is completed\r\n     */\r\n    time?: number;\r\n\r\n    /**\r\n     * Identifies the exclusive time spent in for this event (not including child events),\r\n     * this will be undefined until the event is completed.\r\n     */\r\n    exTime?: number;\r\n\r\n    /**\r\n     * Identifies whether this event is a child event of a parent\r\n     */\r\n    isChildEvt: () => boolean;\r\n\r\n    getCtx?: (key: string) => any | null | undefined;\r\n\r\n    setCtx?: (key: string, value: any) => void;\r\n\r\n    complete: () => void;    \r\n\r\n    constructor(name: string, payloadDetails: () => any, isAsync: boolean) {\r\n        let _self = this;\r\n        let accessorDefined = false;\r\n        _self.start = CoreUtils.dateNow();\r\n        _self.name = name;\r\n        _self.isAsync = isAsync;\r\n        _self.isChildEvt = (): boolean => false;\r\n\r\n        if (CoreUtils.isFunction(payloadDetails)) {\r\n            // Create an accessor to minimize the potential performance impact of executing the payloadDetails callback\r\n            let theDetails:any;\r\n            accessorDefined = CoreUtils.objDefineAccessors(_self, 'payload', () => {\r\n                // Delay the execution of the payloadDetails until needed\r\n                if (!theDetails && CoreUtils.isFunction(payloadDetails)) {\r\n                    theDetails = payloadDetails();\r\n                    // clear it out now so the referenced objects can be garbage collected\r\n                    payloadDetails = null;\r\n                }\r\n\r\n                return theDetails;\r\n            });\r\n        }\r\n\r\n        _self.getCtx = (key: string): any | null | undefined => {\r\n            if (key) {\r\n                // The parent and child links are located directly on the object (for better viewing in the DebugPlugin)\r\n                if (key === PerfEvent.ParentContextKey || key === PerfEvent.ChildrenContextKey) {\r\n                    return _self[key];\r\n                }\r\n\r\n                return  (_self[strExecutionContextKey] || {})[key];\r\n            }\r\n\r\n            return null;\r\n        };\r\n\r\n        _self.setCtx = (key: string, value: any) => {\r\n            if (key) {\r\n                // Put the parent and child links directly on the object (for better viewing in the DebugPlugin)\r\n                if (key === PerfEvent.ParentContextKey) {\r\n                    // Simple assumption, if we are setting a parent then we must be a child\r\n                    if (!_self[key]) {\r\n                        _self.isChildEvt = (): boolean => true;\r\n                    }\r\n                    _self[key] = value;\r\n                } \r\n                else if (key === PerfEvent.ChildrenContextKey) {\r\n                    _self[key] = value;\r\n                } \r\n                else \r\n                {\r\n                    let ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};\r\n                    ctx[key] = value;\r\n                }\r\n            }\r\n        };\r\n\r\n        _self.complete = () => {\r\n            let childTime = 0;\r\n            let childEvts = _self.getCtx(PerfEvent.ChildrenContextKey);\r\n            if (CoreUtils.isArray(childEvts)) {\r\n                for (let lp = 0; lp < childEvts.length; lp++) {\r\n                    let childEvt: IPerfEvent = childEvts[lp];\r\n                    if (childEvt) {\r\n                        childTime += childEvt.time;\r\n                    }\r\n                }\r\n            }\r\n\r\n            _self.time = CoreUtils.dateNow() - _self.start;\r\n            _self.exTime = _self.time - childTime;\r\n            _self.complete = () => {};\r\n            if (!accessorDefined && CoreUtils.isFunction(payloadDetails)) {\r\n                // If we couldn't define the property set during complete -- to minimize the perf impact until after the time\r\n                _self.payload = payloadDetails();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport class PerfManager implements IPerfManager  {\r\n    /**\r\n     * General bucket used for execution context set and retrieved via setCtx() and getCtx.\r\n     * Defined as private so it can be visualized via the DebugPlugin\r\n     */\r\n    private ctx: { [key: string] : any } = {};\r\n\r\n    constructor(manager: INotificationManager) {\r\n\r\n        dynamicProto(PerfManager, this, (_self) => {\r\n\r\n            _self.create = (src: string, payloadDetails?: () => any, isAsync?: boolean): IPerfEvent | null | undefined => {\r\n                // TODO (@MSNev): at some point we will want to add additional configuration to \"select\" which events to instrument\r\n                // for now this is just a simple do everything.\r\n                return new PerfEvent(src, payloadDetails, isAsync);\r\n            };\r\n\r\n            _self.fire = (perfEvent: IPerfEvent) => {\r\n                if (perfEvent) {\r\n                    perfEvent.complete();\r\n\r\n                    if (manager) {\r\n                        manager.perfEvent(perfEvent);\r\n                    }\r\n                }\r\n            };\r\n\r\n            _self.setCtx = (key: string, value: any): void => {\r\n                if (key) {\r\n                    let ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};\r\n                    ctx[key] = value;\r\n                }\r\n            };\r\n        \r\n            _self.getCtx = (key: string): any => {\r\n                return (_self[strExecutionContextKey] || {})[key];\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a new event and start timing, the manager may return null/undefined to indicate that it does not \r\n     * want to monitor this source event.\r\n     * @param src The source name of the event \r\n     * @param payloadDetails - An optional callback function to fetch the payload details for the event.\r\n     * @param isAsync - Is the event occurring from a async event\r\n     */\r\n    public create(src: string, payload?: any, isAsync?: boolean): IPerfEvent | null | undefined {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Complete the perfEvent and fire any notifications.\r\n     * @param perfEvent Fire the event which will also complete the passed event\r\n     */\r\n    public fire(perfEvent: IPerfEvent): void {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    }\r\n\r\n    /**\r\n     * Set an execution context value\r\n     * @param key - The context key name\r\n     * @param value - The value\r\n     */\r\n    public setCtx(key: string, value: any): void {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    }\r\n\r\n    /**\r\n     * Get the execution context value\r\n     * @param key - The context key\r\n     */\r\n    public getCtx(key: string): any {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    }\r\n}\r\n\r\nconst doPerfActiveKey = \"CoreUtils.doPerf\";\r\n\r\n/**\r\n * Helper function to wrap a function with a perf event\r\n * @param mgrSource - The Performance Manager or a Performance provider source (may be null)\r\n * @param getSource - The callback to create the source name for the event (if perf monitoring is enabled)\r\n * @param func - The function to call and measure\r\n * @param details - A function to return the payload details\r\n * @param isAsync - Is the event / function being call asynchronously or synchronously \r\n */\r\nexport function doPerf<T>(mgrSource: IPerfManagerProvider | IPerfManager, getSource: () => string, func: (perfEvt?: IPerfEvent) => T, details?: () => any, isAsync?: boolean) {\r\n    if (mgrSource) {\r\n        let perfMgr: IPerfManager = mgrSource as IPerfManager;\r\n        if (perfMgr && CoreUtils.isFunction(perfMgr[\"getPerfMgr\"])) {\r\n            // Looks like a perf manager provider object\r\n            perfMgr = perfMgr[\"getPerfMgr\"]()\r\n        }\r\n        \r\n        if (perfMgr) {\r\n            let perfEvt: IPerfEvent;\r\n            let currentActive: IPerfEvent = perfMgr.getCtx(doPerfActiveKey);\r\n            try {\r\n                perfEvt = perfMgr.create(getSource(), details, isAsync);\r\n                if (perfEvt) {\r\n                    if (currentActive && perfEvt.setCtx) {\r\n                        perfEvt.setCtx(PerfEvent.ParentContextKey, currentActive);\r\n                        if (currentActive.getCtx && currentActive.setCtx) {\r\n                            let children: IPerfEvent[] = currentActive.getCtx(PerfEvent.ChildrenContextKey);\r\n                            if (!children) {\r\n                                children = [];\r\n                                currentActive.setCtx(PerfEvent.ChildrenContextKey, children);\r\n                            }\r\n    \r\n                            children.push(perfEvt);\r\n                        }\r\n                    }\r\n    \r\n                    // Set this event as the active event now\r\n                    perfMgr.setCtx(doPerfActiveKey, perfEvt);\r\n                    return func(perfEvt);\r\n                }\r\n            } catch (ex) {\r\n                if (perfEvt && perfEvt.setCtx) {\r\n                    perfEvt.setCtx(\"exception\", ex);\r\n                }\r\n            } finally {\r\n                // fire the perf event\r\n                if (perfEvt) {\r\n                    perfMgr.fire(perfEvt);\r\n                }\r\n                \r\n                // Reset the active event to the previous value\r\n                perfMgr.setCtx(doPerfActiveKey, currentActive);\r\n            }\r\n        }\r\n    }\r\n\r\n    return func();\r\n}"]}
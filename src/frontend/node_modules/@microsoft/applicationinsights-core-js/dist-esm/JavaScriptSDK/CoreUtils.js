// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
"use strict";
import { objCreateFn, strShimObject, strShimUndefined, strShimFunction, strShimPrototype } from "@microsoft/applicationinsights-shims";
import { getWindow, getDocument, getCrypto, getPerformance, getMsCrypto, getNavigator } from './EnvUtils';
// Added to help with minfication
export var Undefined = strShimUndefined;
var strOnPrefix = "on";
var strAttachEvent = "attachEvent";
var strAddEventHelper = "addEventListener";
var strDetachEvent = "detachEvent";
var strRemoveEventListener = "removeEventListener";
var UInt32Mask = 0x100000000;
var MaxUInt32 = 0xffffffff;
var _isTrident = null;
// MWC based Random generator (for IE)
var _mwcSeeded = false;
var _mwcW = 123456789;
var _mwcZ = 987654321;
// Takes any integer
function _mwcSeed(seedValue) {
    if (seedValue < 0) {
        // Make sure we end up with a positive number and not -ve one.
        seedValue >>>= 0;
    }
    _mwcW = (123456789 + seedValue) & MaxUInt32;
    _mwcZ = (987654321 - seedValue) & MaxUInt32;
    _mwcSeeded = true;
}
function _autoSeedMwc() {
    // Simple initialization using default Math.random() - So we inherit any entropy from the browser
    // and bitwise XOR with the current milliseconds
    _mwcSeed((Math.random() * UInt32Mask) ^ new Date().getTime());
}
function _isTypeof(value, theType) {
    return typeof value === theType;
}
;
function _isUndefined(value) {
    return _isTypeof(value, strShimUndefined) || value === undefined;
}
;
function _isNullOrUndefined(value) {
    return (_isUndefined(value) || value === null);
}
function _hasOwnProperty(obj, prop) {
    return obj && Object[strShimPrototype].hasOwnProperty.call(obj, prop);
}
;
function _isObject(value) {
    return _isTypeof(value, strShimObject);
}
;
function _isFunction(value) {
    return _isTypeof(value, strShimFunction);
}
;
/**
 * Binds the specified function to an event, so that the function gets called whenever the event fires on the object
 * @param obj Object to add the event too.
 * @param eventNameWithoutOn String that specifies any of the standard DHTML Events without "on" prefix
 * @param handlerRef Pointer that specifies the function to call when event fires
 * @param useCapture [Optional] Defaults to false
 * @returns True if the function was bound successfully to the event, otherwise false
 */
function _attachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
    if (useCapture === void 0) { useCapture = false; }
    var result = false;
    if (!_isNullOrUndefined(obj)) {
        try {
            if (!_isNullOrUndefined(obj[strAddEventHelper])) {
                // all browsers except IE before version 9
                obj[strAddEventHelper](eventNameWithoutOn, handlerRef, useCapture);
                result = true;
            }
            else if (!_isNullOrUndefined(obj[strAttachEvent])) {
                // IE before version 9                    
                obj[strAttachEvent](strOnPrefix + eventNameWithoutOn, handlerRef);
                result = true;
            }
        }
        catch (e) {
            // Just Ignore any error so that we don't break any execution path
        }
    }
    return result;
}
/**
 * Removes an event handler for the specified event
 * @param Object to remove the event from
 * @param eventNameWithoutOn {string} - The name of the event
 * @param handlerRef {any} - The callback function that needs to be executed for the given event
 * @param useCapture [Optional] Defaults to false
 */
function _detachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
    if (useCapture === void 0) { useCapture = false; }
    if (!_isNullOrUndefined(obj)) {
        try {
            if (!_isNullOrUndefined(obj[strRemoveEventListener])) {
                obj[strRemoveEventListener](eventNameWithoutOn, handlerRef, useCapture);
            }
            else if (!_isNullOrUndefined(obj[strDetachEvent])) {
                obj[strDetachEvent](strOnPrefix + eventNameWithoutOn, handlerRef);
            }
        }
        catch (e) {
            // Just Ignore any error so that we don't break any execution path
        }
    }
}
/**
 * Try to define get/set object property accessors for the target object/prototype, this will provide compatibility with
 * existing API definition when run within an ES5+ container that supports accessors but still enable the code to be loaded
 * and executed in an ES3 container, providing basic IE8 compatibility.
 * @param target The object on which to define the property.
 * @param prop The name of the property to be defined or modified.
 * @param getProp The getter function to wire against the getter.
 * @param setProp The setter function to wire against the setter.
 * @returns True if it was able to create the accessors otherwise false
 */
export function objDefineAccessors(target, prop, getProp, setProp) {
    var defineProp = Object["defineProperty"];
    if (defineProp) {
        try {
            var descriptor = {
                enumerable: true,
                configurable: true
            };
            if (getProp) {
                descriptor.get = getProp;
            }
            if (setProp) {
                descriptor.set = setProp;
            }
            defineProp(target, prop, descriptor);
            return true;
        }
        catch (e) {
            // IE8 Defines a defineProperty on Object but it's only supported for DOM elements so it will throw
            // We will just ignore this here.
        }
    }
    return false;
}
/**
 * Validates that the string name conforms to the JS IdentifierName specification and if not
 * normalizes the name so that it would. This method does not identify or change any keywords
 * meaning that if you pass in a known keyword the same value will be returned.
 * This is a simplified version
 * @param name The name to validate
 */
export function normalizeJsName(name) {
    var value = name;
    var match = /([^\w\d_$])/g;
    if (match.test(name)) {
        value = name.replace(match, "_");
    }
    return value;
}
/**
 * This is a helper function for the equivalent of arForEach(objKeys(target), callbackFn), this is a
 * performance optimization to avoid the creation of a new array for large objects
 * @param target The target object to find and process the keys
 * @param callbackfn The function to call with the details
 */
export function objForEachKey(target, callbackfn) {
    if (target && _isObject(target)) {
        for (var prop in target) {
            if (_hasOwnProperty(target, prop)) {
                callbackfn.call(target, prop, target[prop]);
            }
        }
    }
}
/**
 * Effectively assigns all enumerable properties (not just own properties) and functions (including inherited prototype) from
 * the source object to the target, it attempts to use proxy getters / setters (if possible) and proxy functions to avoid potential
 * implementation issues by assigning prototype functions as instance ones
 *
 * This method is the primary method used to "update" the snippet proxy with the ultimate implementations.
 *
 * Special ES3 Notes:
 * Updates (setting) of direct property values on the target or indirectly on the source object WILL NOT WORK PROPERLY, updates to the
 * properties of "referenced" object will work (target.context.newValue = 10 => will be reflected in the source.context as it's the
 * same object). ES3 Failures: assigning target.myProp = 3 -> Won't change source.myProp = 3, likewise the reverse would also fail.
 * @param target - The target object to be assigned with the source properties and functions
 * @param source - The source object which will be assigned / called by setting / calling the targets proxies
 * @param chkSet - An optional callback to determine whether a specific property/function should be proxied
 * @memberof Initialization
 */
export function proxyAssign(target, source, chkSet) {
    if (target && source && target !== source && _isObject(target) && _isObject(source)) {
        var _loop_1 = function (field) {
            if (CoreUtils.isString(field)) {
                var value = source[field];
                if (_isFunction(value)) {
                    if (!chkSet || chkSet(field, true, source, target)) {
                        // Create a proxy function rather than just copying the (possible) prototype to the new object as an instance function
                        target[field] = (function (funcName) {
                            return function () {
                                // Capture the original arguments passed to the method
                                var originalArguments = arguments;
                                return source[funcName].apply(source, originalArguments);
                            };
                        })(field);
                    }
                }
                else if (!chkSet || chkSet(field, false, source, target)) {
                    if (_hasOwnProperty(target, field)) {
                        // Remove any previous instance property
                        delete target[field];
                    }
                    if (!objDefineAccessors(target, field, function () {
                        return source[field];
                    }, function (theValue) {
                        source[field] = theValue;
                    })) {
                        // Unable to create an accessor, so just assign the values as a fallback
                        // -- this will (mostly) work for objects
                        // -- but will fail for accessing primitives (if the source changes it) and all types of "setters" as the source won't be modified
                        target[field] = value;
                    }
                }
            }
        };
        // effectively apply/proxy full source to the target instance
        for (var field in source) {
            _loop_1(field);
        }
    }
    return target;
}
var CoreUtils = /** @class */ (function () {
    function CoreUtils() {
    }
    /**
     * Check if an object is of type Date
     */
    CoreUtils.isDate = function (obj) {
        return Object[strShimPrototype].toString.call(obj) === "[object Date]";
    };
    /**
     * Check if an object is of type Array
     */
    CoreUtils.isArray = function (obj) {
        return Object[strShimPrototype].toString.call(obj) === "[object Array]";
    };
    /**
     * Check if an object is of type Error
     */
    CoreUtils.isError = function (obj) {
        return Object[strShimPrototype].toString.call(obj) === "[object Error]";
    };
    /**
     * Checks if the type of value is a string.
     * @param {any} value - Value to be checked.
     * @return {boolean} True if the value is a string, false otherwise.
     */
    CoreUtils.isString = function (value) {
        return _isTypeof(value, "string");
    };
    /**
     * Checks if the type of value is a number.
     * @param {any} value - Value to be checked.
     * @return {boolean} True if the value is a number, false otherwise.
     */
    CoreUtils.isNumber = function (value) {
        return _isTypeof(value, "number");
    };
    /**
     * Checks if the type of value is a boolean.
     * @param {any} value - Value to be checked.
     * @return {boolean} True if the value is a boolean, false otherwise.
     */
    CoreUtils.isBoolean = function (value) {
        return _isTypeof(value, "boolean");
    };
    /**
     * Creates a new GUID.
     * @return {string} A GUID.
     */
    CoreUtils.disableCookies = function () {
        CoreUtils._canUseCookies = false;
    };
    CoreUtils.newGuid = function () {
        function randomHexDigit() {
            return CoreUtils.randomValue(15); // Get a random value from 0..15
        }
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(GuidRegex, function (c) {
            var r = (randomHexDigit() | 0), v = (c === 'x' ? r : r & 0x3 | 0x8);
            return v.toString(16);
        });
    };
    /**
     * Convert a date to I.S.O. format in IE8
     */
    CoreUtils.toISOString = function (date) {
        if (CoreUtils.isDate(date)) {
            var pad = function (num) {
                var r = String(num);
                if (r.length === 1) {
                    r = "0" + r;
                }
                return r;
            };
            return date.getUTCFullYear()
                + "-" + pad(date.getUTCMonth() + 1)
                + "-" + pad(date.getUTCDate())
                + "T" + pad(date.getUTCHours())
                + ":" + pad(date.getUTCMinutes())
                + ":" + pad(date.getUTCSeconds())
                + "." + String((date.getUTCMilliseconds() / 1000).toFixed(3)).slice(2, 5)
                + "Z";
        }
    };
    /**
     * Performs the specified action for each element in an array. This helper exists to avoid adding a polyfil for older browsers
     * that do not define Array.prototype.xxxx (eg. ES3 only, IE8) just in case any page checks for presence/absence of the prototype
     * implementation. Note: For consistency this will not use the Array.prototype.xxxx implementation if it exists as this would
     * cause a testing requirement to test with and without the implementations
     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
     * @param thisArg  [Optional] An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    CoreUtils.arrForEach = function (arr, callbackfn, thisArg) {
        var len = arr.length;
        for (var idx = 0; idx < len; idx++) {
            if (idx in arr) {
                callbackfn.call(thisArg || arr, arr[idx], idx, arr);
            }
        }
    };
    /**
     * Returns the index of the first occurrence of a value in an array. This helper exists to avoid adding a polyfil for older browsers
     * that do not define Array.prototype.xxxx (eg. ES3 only, IE8) just in case any page checks for presence/absence of the prototype
     * implementation. Note: For consistency this will not use the Array.prototype.xxxx implementation if it exists as this would
     * cause a testing requirement to test with and without the implementations
     * @param searchElement The value to locate in the array.
     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
     */
    CoreUtils.arrIndexOf = function (arr, searchElement, fromIndex) {
        var len = arr.length;
        var from = fromIndex || 0;
        for (var lp = Math.max(from >= 0 ? from : len - Math.abs(from), 0); lp < len; lp++) {
            if (lp in arr && arr[lp] === searchElement) {
                return lp;
            }
        }
        return -1;
    };
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results. This helper exists
     * to avoid adding a polyfil for older browsers that do not define Array.prototype.xxxx (eg. ES3 only, IE8) just in case any page
     * checks for presence/absence of the prototype implementation. Note: For consistency this will not use the Array.prototype.xxxx
     * implementation if it exists as this would cause a testing requirement to test with and without the implementations
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    CoreUtils.arrMap = function (arr, callbackfn, thisArg) {
        var len = arr.length;
        var _this = thisArg || arr;
        var results = new Array(len);
        for (var lp = 0; lp < len; lp++) {
            if (lp in arr) {
                results[lp] = callbackfn.call(_this, arr[lp], arr);
            }
        }
        return results;
    };
    /**
     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is
     * provided as an argument in the next call to the callback function. This helper exists to avoid adding a polyfil for older browsers that do not define
     * Array.prototype.xxxx (eg. ES3 only, IE8) just in case any page checks for presence/absence of the prototype implementation. Note: For consistency
     * this will not use the Array.prototype.xxxx implementation if it exists as this would cause a testing requirement to test with and without the implementations
     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
     */
    CoreUtils.arrReduce = function (arr, callbackfn, initialValue) {
        var len = arr.length;
        var lp = 0;
        var value;
        // Specifically checking the number of passed arguments as the value could be anything
        if (arguments.length >= 3) {
            value = arguments[2];
        }
        else {
            while (lp < len && !(lp in arr)) {
                lp++;
            }
            value = arr[lp++];
        }
        while (lp < len) {
            if (lp in arr) {
                value = callbackfn(value, arr[lp], lp, arr);
            }
            lp++;
        }
        return value;
    };
    /**
     * helper method to trim strings (IE8 does not implement String.prototype.trim)
     */
    CoreUtils.strTrim = function (str) {
        if (!CoreUtils.isString(str)) {
            return str;
        }
        return str.replace(/^\s+|\s+$/g, "");
    };
    /**
     * Returns the names of the enumerable string properties and methods of an object. This helper exists to avoid adding a polyfil for older browsers
     * that do not define Object.keys eg. ES3 only, IE8 just in case any page checks for presence/absence of the prototype implementation.
     * Note: For consistency this will not use the Object.keys implementation if it exists as this would cause a testing requirement to test with and without the implementations
     * @param obj Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.
     */
    CoreUtils.objKeys = function (obj) {
        var hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString');
        if (!_isFunction(obj) && (!_isObject(obj) || obj === null)) {
            throw new TypeError('objKeys called on non-object');
        }
        var result = [];
        for (var prop in obj) {
            if (_hasOwnProperty(obj, prop)) {
                result.push(prop);
            }
        }
        if (hasDontEnumBug) {
            var dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];
            var dontEnumsLength = dontEnums.length;
            for (var lp = 0; lp < dontEnumsLength; lp++) {
                if (_hasOwnProperty(obj, dontEnums[lp])) {
                    result.push(dontEnums[lp]);
                }
            }
        }
        return result;
    };
    /**
     * Trys to add an event handler for the specified event to the window, body and document
     * @param eventName {string} - The name of the event
     * @param callback {any} - The callback function that needs to be executed for the given event
     * @return {boolean} - true if the handler was successfully added
     */
    CoreUtils.addEventHandler = function (eventName, callback) {
        var result = false;
        var w = getWindow();
        if (w) {
            result = _attachEvent(w, eventName, callback);
            result = _attachEvent(w["body"], eventName, callback) || result;
        }
        var doc = getDocument();
        if (doc) {
            result = EventHelper.Attach(doc, eventName, callback) || result;
        }
        return result;
    };
    /**
     * Return the current time via the Date now() function (if available) and falls back to (new Date()).getTime() if now() is unavailable (IE8 or less)
     * https://caniuse.com/#search=Date.now
     */
    CoreUtils.dateNow = function () {
        var dt = Date;
        if (dt.now) {
            return dt.now();
        }
        return new dt().getTime();
    };
    /**
     * Return the current value of the Performance Api now() function (if available) and fallback to CoreUtils.dateNow() if it is unavailable (IE9 or less)
     * https://caniuse.com/#search=performance.now
     */
    CoreUtils.perfNow = function () {
        var perf = getPerformance();
        if (perf && perf.now) {
            return perf.now();
        }
        return CoreUtils.dateNow();
    };
    /**
     * Generate random base64 id string.
     * The default length is 22 which is 132-bits so almost the same as a GUID but as base64 (the previous default was 5)
     * @param maxLength - Optional value to specify the length of the id to be generated, defaults to 22
     */
    CoreUtils.newId = function (maxLength) {
        if (maxLength === void 0) { maxLength = 22; }
        var base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        // Start with an initial random number, consuming the value in reverse byte order
        var number = CoreUtils.random32() >>> 0; // Make sure it's a +ve number
        var chars = 0;
        var result = "";
        while (result.length < maxLength) {
            chars++;
            result += base64chars.charAt(number & 0x3F);
            number >>>= 6; // Zero fill with right shift
            if (chars === 5) {
                // 5 base64 characters === 30 bits so we don't have enough bits for another base64 char
                // So add on another 30 bits and make sure it's +ve
                number = (((CoreUtils.random32() << 2) & 0xFFFFFFFF) | (number & 0x03)) >>> 0;
                chars = 0; // We need to reset the number every 5 chars (30 bits)
            }
        }
        return result;
    };
    /**
     * Identifies whether the current environment appears to be IE
     */
    CoreUtils.isIE = function () {
        if (_isTrident === null) {
            var navigator_1 = getNavigator() || {};
            var userAgent = (navigator_1.userAgent || "").toLowerCase();
            _isTrident = (userAgent.indexOf("msie") !== -1 || userAgent.indexOf("trident/") !== -1);
        }
        return _isTrident;
    };
    /**
     * Generate a random value between 0 and maxValue, max value should be limited to a 32-bit maximum.
     * So maxValue(16) will produce a number from 0..16 (range of 17)
     * @param maxValue
     */
    CoreUtils.randomValue = function (maxValue) {
        if (maxValue > 0) {
            return Math.floor((CoreUtils.random32() / MaxUInt32) * (maxValue + 1)) >>> 0;
        }
        return 0;
    };
    /**
     * generate a random 32-bit number (0x000000..0xFFFFFFFF) or (-0x80000000..0x7FFFFFFF), defaults un-unsigned.
     * @param signed - True to return a signed 32-bit number (-0x80000000..0x7FFFFFFF) otherwise an unsigned one (0x000000..0xFFFFFFFF)
     */
    CoreUtils.random32 = function (signed) {
        var value;
        var c = getCrypto() || getMsCrypto();
        if (c && c.getRandomValues) {
            // Make sure the number is converted into the specified range (-0x80000000..0x7FFFFFFF)
            value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32;
        }
        else if (CoreUtils.isIE()) {
            // For IE 6, 7, 8 (especially on XP) Math.random is not very random
            if (!_mwcSeeded) {
                // Set the seed for the Mwc algorithm
                _autoSeedMwc();
            }
            // Don't use Math.random for IE
            // Make sure the number is converted into the specified range (-0x80000000..0x7FFFFFFF)
            value = CoreUtils.mwcRandom32() & MaxUInt32;
        }
        else {
            // Make sure the number is converted into the specified range (-0x80000000..0x7FFFFFFF)
            value = Math.floor((UInt32Mask * Math.random()) | 0);
        }
        if (!signed) {
            // Make sure we end up with a positive number and not -ve one.
            value >>>= 0;
        }
        return value;
    };
    /**
     * Seed the MWC random number generator with the specified seed or a random value
     * @param value - optional the number to used as the seed, if undefined, null or zero a random value will be chosen
     */
    CoreUtils.mwcRandomSeed = function (value) {
        if (!value) {
            _autoSeedMwc();
        }
        else {
            _mwcSeed(value);
        }
    };
    /**
     * Generate a random 32-bit number between (0x000000..0xFFFFFFFF) or (-0x80000000..0x7FFFFFFF), using MWC (Multiply with carry)
     * instead of Math.random() defaults to un-signed.
     * Used as a replacement random generator for IE to avoid issues with older IE instances.
     * @param signed - True to return a signed 32-bit number (-0x80000000..0x7FFFFFFF) otherwise an unsigned one (0x000000..0xFFFFFFFF)
     */
    CoreUtils.mwcRandom32 = function (signed) {
        _mwcZ = (36969 * (_mwcZ & 0xFFFF) + (_mwcZ >> 16)) & MaxUInt32;
        _mwcW = (18000 * (_mwcW & 0xFFFF) + (_mwcW >> 16)) & MaxUInt32;
        var value = (((_mwcZ << 16) + (_mwcW & 0xFFFF)) >>> 0) & MaxUInt32 | 0;
        if (!signed) {
            // Make sure we end up with a positive number and not -ve one.
            value >>>= 0;
        }
        return value;
    };
    /**
     * generate W3C trace id
     */
    CoreUtils.generateW3CId = function () {
        var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
        // rfc4122 version 4 UUID without dashes and with lowercase letters
        var oct = "", tmp;
        for (var a = 0; a < 4; a++) {
            tmp = CoreUtils.random32();
            oct +=
                hexValues[tmp & 0xF] +
                    hexValues[tmp >> 4 & 0xF] +
                    hexValues[tmp >> 8 & 0xF] +
                    hexValues[tmp >> 12 & 0xF] +
                    hexValues[tmp >> 16 & 0xF] +
                    hexValues[tmp >> 20 & 0xF] +
                    hexValues[tmp >> 24 & 0xF] +
                    hexValues[tmp >> 28 & 0xF];
        }
        // "Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively"
        var clockSequenceHi = hexValues[8 + (CoreUtils.random32() & 0x03) | 0];
        return oct.substr(0, 8) + oct.substr(9, 4) + "4" + oct.substr(13, 3) + clockSequenceHi + oct.substr(16, 3) + oct.substr(19, 12);
    };
    CoreUtils.isTypeof = _isTypeof;
    CoreUtils.isUndefined = _isUndefined;
    CoreUtils.isNullOrUndefined = _isNullOrUndefined;
    CoreUtils.hasOwnProperty = _hasOwnProperty;
    /**
     * Checks if the passed of value is a function.
     * @param {any} value - Value to be checked.
     * @return {boolean} True if the value is a boolean, false otherwise.
     */
    CoreUtils.isFunction = _isFunction;
    /**
     * Checks if the passed of value is a function.
     * @param {any} value - Value to be checked.
     * @return {boolean} True if the value is a boolean, false otherwise.
     */
    CoreUtils.isObject = _isObject;
    /**
     * Creates an object that has the specified prototype, and that optionally contains specified properties. This helper exists to avoid adding a polyfil
     * for older browsers that do not define Object.create eg. ES3 only, IE8 just in case any page checks for presence/absence of the prototype implementation.
     * Note: For consistency this will not use the Object.create implementation if it exists as this would cause a testing requirement to test with and without the implementations
     * @param obj Object to use as a prototype. May be null
     */
    // tslint:disable-next-line: member-ordering
    CoreUtils.objCreate = objCreateFn;
    /**
     * Try to define get/set object property accessors for the target object/prototype, this will provide compatibility with
     * existing API definition when run within an ES5+ container that supports accessors but still enable the code to be loaded
     * and executed in an ES3 container, providing basic IE8 compatibility.
     * @param target The object on which to define the property.
     * @param prop The name of the property to be defined or modified.
     * @param getProp The getter function to wire against the getter.
     * @param setProp The setter function to wire against the setter.
     * @returns True if it was able to create the accessors otherwise false
     */
    CoreUtils.objDefineAccessors = objDefineAccessors;
    return CoreUtils;
}());
export { CoreUtils };
var GuidRegex = /[xy]/g;
var EventHelper = /** @class */ (function () {
    function EventHelper() {
    }
    /**
     * Binds the specified function to an event, so that the function gets called whenever the event fires on the object
     * @param obj Object to add the event too.
     * @param eventNameWithoutOn String that specifies any of the standard DHTML Events without "on" prefix
     * @param handlerRef Pointer that specifies the function to call when event fires
     * @returns True if the function was bound successfully to the event, otherwise false
     */
    EventHelper.Attach = _attachEvent;
    /**
     * Binds the specified function to an event, so that the function gets called whenever the event fires on the object
     * @deprecated Use {@link EventHelper#Attach} as we are already in a class call EventHelper the extra "Event" just causes a larger result
     * @param obj Object to add the event too.
     * @param eventNameWithoutOn String that specifies any of the standard DHTML Events without "on" prefix
     * @param handlerRef Pointer that specifies the function to call when event fires
     * @returns True if the function was bound successfully to the event, otherwise false
     */
    EventHelper.AttachEvent = _attachEvent;
    /**
     * Removes an event handler for the specified event
     * @param eventName {string} - The name of the event
     * @param callback {any} - The callback function that needs to be executed for the given event
     * @return {boolean} - true if the handler was successfully added
     */
    EventHelper.Detach = _detachEvent;
    /**
     * Removes an event handler for the specified event
     * @deprecated Use {@link EventHelper#Detach} as we are already in a class call EventHelper the extra "Event" just causes a larger result
     * @param eventName {string} - The name of the event
     * @param callback {any} - The callback function that needs to be executed for the given event
     * @return {boolean} - true if the handler was successfully added
     */
    EventHelper.DetachEvent = _detachEvent;
    return EventHelper;
}());
export { EventHelper };
//# sourceMappingURL=CoreUtils.js.map
import { Dispatch, SetStateAction } from 'react';
export declare type Parameter<T extends (arg: any) => void> = T extends (arg: infer P) => void ? P : never;
export declare type EventHandlerParameter<TEvent extends Events, TKey extends keyof TEvent, THandler extends TEvent[TKey] = TEvent[TKey]> = THandler extends (arg: infer P) => void ? P : never;
export declare type Events = {
    [key: string]: (arg: any) => void;
};
export interface IEventEmitter<TEvents extends Events> {
    on<TKey extends keyof TEvents>(key: TKey, handler: (arg: EventHandlerParameter<TEvents, TKey>) => void): () => void;
}
export default abstract class EventEmitter<TEvents extends Events> {
    private handlers;
    on<TKey extends keyof TEvents>(key: TKey, handler: (arg: EventHandlerParameter<TEvents, TKey>) => void): () => void;
    protected emit<TKey extends keyof TEvents, TParameter = EventHandlerParameter<TEvents, TKey>>(key: TKey, arg: TParameter): this;
}
export declare const useEventEmitterValue: <TEvents extends Events, TKey extends keyof TEvents, TData = EventHandlerParameter<TEvents, TKey, TEvents[TKey]>>(emitter: EventEmitter<TEvents>, event: TKey, transform?: (value: TData) => TData | null, defaultData?: TData | null) => [TData | null, Dispatch<SetStateAction<TData | null>>];
export declare const useEventEmitter: <TEvents extends Events, TKey extends keyof TEvents, TData = EventHandlerParameter<TEvents, TKey, TEvents[TKey]>>(emitter: EventEmitter<TEvents>, event: TKey, handler: (arg: TData) => void) => void;

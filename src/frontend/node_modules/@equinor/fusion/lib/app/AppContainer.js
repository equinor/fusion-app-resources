import EventEmitter, { useEventEmitterValue } from '../utils/EventEmitter';
import { useFusionContext } from '../core/FusionContext';
import { useEffect, useState } from 'react';
import DistributedState from '../utils/DistributedState';
const compareApp = (a, b) => {
    if (!b)
        return true;
    const attr = Object.keys(a);
    return attr.some((key) => {
        var _a, _b;
        switch (key) {
            case 'auth':
            //@todo maybe?!?!
            case 'context':
            case 'tags':
                return false;
            case 'category':
                return ((_a = a.category) === null || _a === void 0 ? void 0 : _a.id) !== ((_b = b.category) === null || _b === void 0 ? void 0 : _b.id);
            // Dates
            case 'publishedDate':
                return String(a[key]) !== String(b[key]);
            default:
                return a[key] !== b[key];
        }
    });
};
const compareApps = (a, b) => {
    if (!a || !b)
        return a === b;
    if (Object.keys(a).length !== Object.keys(b).length)
        return true;
    return Object.keys(a).some((key) => compareApp(a[key], b[key]));
};
export default class AppContainer extends EventEmitter {
    constructor(apiClients, telemetryLogger, featureLogger, eventHub) {
        super();
        this.featureLogger = featureLogger;
        this._updatePromise = Promise.resolve();
        this.fusionClient = apiClients.fusion;
        this.telemetryLogger = telemetryLogger;
        this._currentApp = new DistributedState('AppContainer.currentApp', null, eventHub);
        this._currentApp.on('change', (updatedApp) => {
            this.emit('change', updatedApp);
        });
        this.apps = new DistributedState('AppContainer.apps', {}, eventHub);
        this.apps.on('change', (apps) => this.emit('update', apps));
        this.previousApps = new DistributedState('AppContainer.previousApps', {}, eventHub);
        this.on('fetch', (fetching) => (this._isUpdating = fetching));
    }
    get isUpdating() {
        return !!this._isUpdating;
    }
    get lastUpdated() {
        return this._lastUpdated;
    }
    get requireUpdate() {
        return !this._isUpdating;
    }
    get updateComplete() {
        return this._updatePromise;
    }
    get currentApp() {
        return this._currentApp.state;
    }
    get allApps() {
        return this.apps.state;
    }
    updateManifest(manifest) {
        this.addOrUpdate({ [manifest.key]: manifest });
    }
    get(appKey) {
        return appKey && this.apps.state[appKey];
    }
    getAll() {
        return Object.values(this.apps.state);
    }
    async setCurrentAppAsync(appKey) {
        const previousApp = this.previousApps.state[0];
        if (this.currentApp && (!previousApp || previousApp.key !== appKey)) {
            this.previousApps.state = Object.assign(Object.assign({}, this.previousApps.state), { [this.currentApp.key]: this.currentApp });
        }
        if (!appKey) {
            this.featureLogger.log('App selected', '0.0.1', {
                selectedApp: null,
                previousApps: Object.keys(this.previousApps.state).map((key) => ({
                    key,
                    name: this.previousApps.state[key].name,
                })),
            });
            this.featureLogger.setCurrentApp(null);
            this._currentApp.state = null;
            this.emit('change', null);
            return;
        }
        const app = this.get(appKey);
        if (!app) {
            const { data: manifest } = await this.fusionClient.getAppManifestAsync(appKey);
            const appManifest = Object.assign(Object.assign({}, manifest), { key: appKey });
            this.updateManifest(appManifest);
            return await this.setCurrentAppAsync(appKey);
        }
        if (!app.AppComponent) {
            await this.fusionClient.loadAppScriptAsync(appKey);
            return await this.setCurrentAppAsync(appKey);
        }
        this.telemetryLogger.trackEvent({
            name: 'App selected',
            properties: {
                previousApp: this._currentApp.state ? this._currentApp.state.name : null,
                selectedApp: app.name,
                previousApps: Object.keys(this.previousApps.state).map((key) => this.previousApps.state[key].name),
                currentApp: app.name,
            },
        });
        if (!app.context) {
            // Reset context on feature logger if current app does not support it
            this.featureLogger.setCurrentContext(null, null);
        }
        this.featureLogger.log('App selected', '0.0.1', {
            selectedApp: {
                key: app.key,
                name: app.name,
            },
            previousApps: Object.keys(this.previousApps.state).map((key) => ({
                key,
                name: this.previousApps.state[key].name,
            })),
        });
        this.featureLogger.setCurrentApp(app.key);
        this._currentApp.state = app;
        this.emit('change', app);
    }
    async getAllAsync() {
        await this.requestUpdate();
        return this.allApps;
    }
    requestUpdate() {
        return this.requireUpdate ? this.update() : this._updatePromise;
    }
    update() {
        this._updatePromise = new Promise(async (resolve, reject) => {
            try {
                this.emit('fetch', true);
                const response = await this.fusionClient.getAppsAsync();
                const apps = response.data.reduce((cur, val) => Object.assign(cur, { [val.key]: val }), {});
                this.addOrUpdate(apps);
                this._lastUpdated = Date.now();
                resolve();
            }
            catch (err) {
                reject(err);
            }
            finally {
                this.emit('fetch', false);
            }
        });
        return this._updatePromise;
    }
    addOrUpdate(apps) {
        if (compareApps(this.apps.state, apps)) {
            const nextState = Object.keys(apps).reduce((cur, key) => (Object.assign(Object.assign({}, cur), { [key]: Object.assign(Object.assign({}, cur[key]), apps[key]) })), Object.assign({}, this.apps.state));
            this.apps.state = Object.freeze(nextState);
        }
    }
}
let appContainerInstance = null;
let appContainerPromise = null;
let setAppContainerSingleton;
const appContainerFactory = (appContainer) => {
    appContainerInstance = appContainer;
    if (setAppContainerSingleton) {
        setAppContainerSingleton(appContainer);
        setAppContainerSingleton = null;
    }
};
const getAppContainer = () => {
    if (appContainerInstance) {
        return Promise.resolve(appContainerInstance);
    }
    if (appContainerPromise) {
        return appContainerPromise;
    }
    appContainerPromise = new Promise((resolve) => {
        setAppContainerSingleton = resolve;
    });
    return appContainerPromise;
};
const registerApp = (key, manifest) => {
    getAppContainer().then((appContainer) => appContainer.updateManifest(Object.assign(Object.assign({}, manifest), { key })));
};
const useCurrentApp = () => {
    const { app } = useFusionContext();
    useEventEmitterValue(app.container, 'change', (app) => app, app.container.currentApp);
    // Only to get notified/rerendered when changes are made to the current app
    useEventEmitterValue(app.container, 'update');
    return app.container.currentApp;
};
const useApps = (buffer = 60000) => {
    const { app: { container }, } = useFusionContext();
    const [apps, setApps] = useState(container.allApps);
    const [isFetching, setIsFetching] = useState(container.isUpdating);
    const [initialized, setInitialized] = useState((container.lastUpdated || 0) + buffer >= Date.now());
    const [error, setError] = useState(null);
    useEffect(() => container.on('fetch', (status) => setIsFetching(status)), []);
    useEffect(() => {
        !initialized &&
            container
                .requestUpdate()
                .then(() => setInitialized(true))
                .catch(setError);
        return container.on('update', setApps);
    }, []);
    return { error, initialized, isFetching, apps };
};
export { registerApp, appContainerFactory, useCurrentApp, useApps };

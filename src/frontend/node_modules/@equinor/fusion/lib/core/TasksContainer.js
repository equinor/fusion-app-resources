import EventEmitter, { useEventEmitterValue } from '../utils/EventEmitter';
import { useState, useEffect } from 'react';
import { useFusionContext } from './FusionContext';
import DistributedState from '../utils/DistributedState';
export default class TasksContainer extends EventEmitter {
    constructor(apiClients, eventHub) {
        super();
        this.tasks = new DistributedState('TaskContainer.Tasks', [], eventHub);
        this.tasks.on('change', (tasks) => {
            this.emit('tasks-updated', tasks);
        });
        this.taskTypes = new DistributedState('TaskContainer.TaskTypes', [], eventHub);
        this.taskTypes.on('change', (taskTypes) => {
            this.emit('task-types-updated', taskTypes);
        });
        this.sourceSystems = new DistributedState('TaskContainer.SourceSysytems', [], eventHub);
        this.sourceSystems.on('change', (sourceSystems) => {
            this.emit('source-systems-updated', sourceSystems);
        });
        this.tasksClient = apiClients.tasks;
    }
    async getAllTasksAsync() {
        const taskTypes = await this.getTaskTypesAsync();
        const taskPromises = taskTypes.map((taskType) => this.getTasksAsync(taskType.key));
        await Promise.all(taskPromises);
        return this.tasks.state;
    }
    async getTasksAsync(taskType) {
        const response = await this.tasksClient.getAllTasksAsync(taskType);
        this.mergeTasks(response.data);
        if (response.refreshRequest) {
            return await this.refreshTasksAsync(taskType, response.refreshRequest);
        }
        return response.data;
    }
    async getTaskTypesAsync() {
        const response = await this.tasksClient.getTaskTypesAsync();
        this.setTaskTypes(response.data);
        return response.data;
    }
    async getSourceSystemsAsync() {
        const response = await this.tasksClient.getSourceSystemsAsync();
        this.setSourceSystems(response.data);
        return response.data;
    }
    async setTaskPriorityAsync(id, priority) {
        const task = this.getTasks().find((t) => t.id === id);
        if (!task) {
            throw new Error("Can't find the task with id: " + id);
        }
        const previousPriority = task.priority;
        try {
            // Immediately update the priority on the task for quick UI response
            const updatedTask = Object.assign(Object.assign({}, task), { priority });
            this.mergeTasks([updatedTask]);
            await this.tasksClient.setTaskPriorityAsync(id, priority);
        }
        catch (e) {
            // Revert the task priority if it failed
            const revertedTask = Object.assign(Object.assign({}, task), { priority: previousPriority });
            this.mergeTasks([revertedTask]);
        }
    }
    getTasks(taskType) {
        if (!taskType) {
            return [...this.tasks.state];
        }
        return this.tasks.state.filter((t) => t.taskTypeKey == taskType);
    }
    getTaskTypes() {
        return [...this.taskTypes.state];
    }
    getSourceSystems() {
        return [...this.sourceSystems.state];
    }
    async refreshTasksAsync(taskType, refreshRequest) {
        const response = await this.tasksClient.refreshTasksAsync(taskType, refreshRequest);
        this.mergeTasks(response.data);
        return response.data;
    }
    mergeTasks(tasks) {
        // Extract new tasks from the list of tasks
        const newTasks = tasks.filter((t) => !this.tasks.state.find((e) => e.id === t.id));
        // Merge new tasks with the existing
        const mergedTasks = [...this.tasks.state, ...newTasks];
        // Overwrite existing tasks with updated tasks
        this.tasks.state = mergedTasks.map((t) => tasks.find((n) => n.id === t.id) || t);
        this.emit('tasks-updated', this.tasks.state);
    }
    setTaskTypes(taskTypes) {
        this.taskTypes.state = taskTypes;
        this.emit('task-types-updated', taskTypes);
    }
    setSourceSystems(sourceSystems) {
        this.sourceSystems.state = sourceSystems;
        this.emit('source-systems-updated', sourceSystems);
    }
}
const useTasksContainer = () => {
    const { tasksContainer } = useFusionContext();
    return tasksContainer;
};
const useTasksData = (event, fetchAsync, defaultData) => {
    const tasksContainer = useTasksContainer();
    const [error, setError] = useState(null);
    const [isFetching, setIsFetching] = useState(false);
    const [defaultDataState] = useState(defaultData);
    const [data, setData] = useEventEmitterValue(tasksContainer, event, (t) => t, defaultDataState);
    const fetch = async () => {
        setIsFetching(true);
        try {
            const data = await fetchAsync(tasksContainer);
            setData(data);
        }
        catch (e) {
            setError(e);
        }
        setIsFetching(false);
    };
    useEffect(() => {
        fetch();
    }, []);
    return [error, isFetching, data || defaultDataState];
};
const useTaskSourceSystems = () => {
    return useTasksData('source-systems-updated', async (tasksContainer) => await tasksContainer.getSourceSystemsAsync(), useTasksContainer().getSourceSystems());
};
const useTaskTypes = () => {
    return useTasksData('task-types-updated', async (tasksContainer) => await tasksContainer.getTaskTypesAsync(), useTasksContainer().getTaskTypes());
};
const useTaskPrioritySetter = () => {
    const { tasksContainer } = useFusionContext();
    return async (id, priority) => {
        await tasksContainer.setTaskPriorityAsync(id, priority);
    };
};
const useTasks = () => {
    const [sourceSystemsError, isFetchingSourceSystems, sourceSystems] = useTaskSourceSystems();
    const [taskTypesError, isFetchingTaskTypes, taskTypes] = useTaskTypes();
    const [tasksError, isFetchingTasks, tasks] = useTasksData('tasks-updated', async (tasksContainer) => await tasksContainer.getAllTasksAsync(), useTasksContainer().getTasks());
    const error = sourceSystemsError || taskTypesError || tasksError;
    const isFetching = isFetchingTaskTypes || isFetchingTasks;
    return {
        error,
        isFetching,
        tasks,
        isFetchingTaskTypes,
        taskTypes,
        isFetchingSourceSystems,
        sourceSystems,
    };
};
export { useTasksContainer, useTasks, useTaskSourceSystems, useTaskTypes, useTaskPrioritySetter };

import { useState, useCallback, useEffect } from 'react';
import { useFusionContext } from './FusionContext';
import ReliableDictionary, { LocalStorageProvider } from '../utils/ReliableDictionary';
import useDebouncedAbortable from '../hooks/useDebouncedAbortable';
import useApiClients from '../http/hooks/useApiClients';
import EventHub from '../utils/EventHub';
import { useCurrentApp } from '../app/AppContainer';
import { combineUrls } from '../utils/url';
export default class ContextManager extends ReliableDictionary {
    constructor(apiClients, appContainer, featureLogger, telemetryLogger, history) {
        super(new LocalStorageProvider(`FUSION_CURRENT_CONTEXT`, new EventHub()));
        this.appContainer = appContainer;
        this.featureLogger = featureLogger;
        this.telemetryLogger = telemetryLogger;
        this.history = history;
        this.isSettingFromRoute = false;
        this.appHasContext = () => { var _a; return Boolean((_a = this.appContainer.currentApp) === null || _a === void 0 ? void 0 : _a.context); };
        this.getAppPath = () => { var _a; return `/apps/${(_a = this.appContainer.currentApp) === null || _a === void 0 ? void 0 : _a.key}`; };
        this.urlHasPath = (path) => this.history.location.pathname.indexOf(path) !== -1;
        this.getScopedPath = (path) => this.history.location.pathname.replace(path, '');
        this.buildUrlWithContext = async () => {
            var _a, _b;
            const currentContext = await this.getCurrentContextAsync();
            const buildUrl = (_b = (_a = this.appContainer.currentApp) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.buildUrl;
            if (!this.appHasContext() ||
                !buildUrl ||
                !(currentContext === null || currentContext === void 0 ? void 0 : currentContext.id) ||
                this.history.location.pathname.indexOf(currentContext.id) !== -1)
                return null;
            const appPath = this.getAppPath();
            const newUrl = combineUrls(this.urlHasPath(appPath) ? appPath : '', buildUrl(currentContext, this.getScopedPath(appPath)));
            return newUrl;
        };
        this.ensureCurrentContextExistsInUrl = async () => {
            if (!this.appHasContext())
                return;
            const newUrl = await this.buildUrlWithContext();
            if (newUrl && this.history.location.pathname.indexOf(newUrl) !== 0)
                this.history.push(newUrl);
        };
        this.contextClient = apiClients.context;
        const unlistenAppContainer = this.appContainer.on('change', (app) => {
            this.resolveContextFromUrlOrLocalStorageAsync(app);
            unlistenAppContainer();
        });
        this.history.listen(this.ensureCurrentContextExistsInUrl);
    }
    async resolveContextFromUrlOrLocalStorageAsync(app) {
        if (!app || !app.context)
            return;
        const getContextFromUrl = app.context.getContextFromUrl;
        const contextId = getContextFromUrl && this.history.location && this.history.location.pathname
            ? getContextFromUrl(this.getScopedPath(this.getAppPath()))
            : null;
        if (contextId)
            return this.setCurrentContextFromIdAsync(contextId);
        this.ensureCurrentContextExistsInUrl();
    }
    async validateContext(context) {
        var _a;
        if (!context)
            return;
        try {
            const validContext = await this.contextClient.getContextAsync(context.id);
            if (validContext === null || validContext === void 0 ? void 0 : validContext.data) {
                this.featureLogger.setCurrentContext(context.id, context.title);
                const history = await this.getAsync('history');
                this.featureLogger.log('Context selected', '0.0.1', {
                    selectedContext: context
                        ? {
                            id: context.id,
                            name: context.title,
                        }
                        : null,
                    previusContexts: (history || []).map((c) => ({ id: c.id, name: c.title })),
                });
                this.telemetryLogger.trackEvent({
                    name: 'Project selected',
                    properties: {
                        projectId: context.id,
                        projectName: context.title,
                        currentApp: (_a = this.appContainer.currentApp) === null || _a === void 0 ? void 0 : _a.name,
                    },
                });
                return;
            }
            await this.setAsync('current', null);
            this.featureLogger.setCurrentContext(null, null);
        }
        catch (_b) {
            await this.setAsync('current', null);
            this.featureLogger.setCurrentContext(null, null);
        }
    }
    async setCurrentContextAsync(context) {
        var _a, _b, _c;
        const buildUrl = (_b = (_a = this.appContainer.currentApp) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.buildUrl;
        const currentContext = await this.getAsync('current');
        if ((currentContext === null || currentContext === void 0 ? void 0 : currentContext.id) === (context === null || context === void 0 ? void 0 : context.id)) {
            return this.ensureCurrentContextExistsInUrl();
        }
        const appPath = `/apps/${(_c = this.appContainer.currentApp) === null || _c === void 0 ? void 0 : _c.key}`;
        const hasAppPath = this.history.location.pathname.indexOf(appPath) !== -1;
        const scopedPath = this.history.location.pathname.replace(appPath, '');
        if (buildUrl) {
            const newUrl = combineUrls(hasAppPath ? appPath : '', buildUrl(context, scopedPath + this.history.location.search));
            if (this.history.location.pathname.indexOf(newUrl) !== 0)
                this.history.push(newUrl);
        }
        await this.setAsync('current', context);
        this.validateContext(context);
        if (!currentContext) {
            return;
        }
        try {
            const previousContext = await this.contextClient.getContextAsync(currentContext.id);
            if (!previousContext)
                return;
            this.updateHistoryAsync(previousContext.data);
            if (context)
                this.updateLinksAsync(previousContext.data, context);
        }
        catch (_d) {
            return;
        }
    }
    async setCurrentContextIdAsync(id) {
        if (!id) {
            return await this.setCurrentContextAsync(null);
        }
        try {
            const response = await this.contextClient.getContextAsync(id);
            await this.setCurrentContextAsync(response.data);
        }
        catch (e) {
            this.telemetryLogger.trackException(e);
            await this.setCurrentContextAsync(null);
        }
    }
    async updateHistoryAsync(currentContext) {
        const newHistory = [currentContext];
        const history = await this.getAsync('history');
        if (history) {
            history
                // Remove the current context from the previous history (it's added to the start of the history)
                .filter((c) => c.id !== currentContext.id)
                // Remove historical contexts after the last 10 (currentContext + 9)
                .slice(0, 9)
                .forEach((c) => newHistory.push(c));
        }
        await this.setAsync('history', newHistory);
    }
    async updateLinksAsync(currentContext, newContext) {
        const links = await this.getAsync('links');
        await this.setAsync('links', Object.assign(Object.assign({}, (links || {})), { [currentContext.id]: newContext.id }));
    }
    async getLinkedContextAsync(context) {
        const links = await this.getAsync('links');
        if (!links || !links[context.id]) {
            return null;
        }
        const linkedContextId = links[context.id];
        const history = await this.getAsync('history');
        const contextFromHistory = history ? history.find((c) => c.id === linkedContextId) : null;
        if (contextFromHistory) {
            return contextFromHistory;
        }
        try {
            const response = await this.contextClient.getContextAsync(linkedContextId);
            return response.data || null;
        }
        catch (_a) {
            return null;
        }
    }
    getCurrentContext() {
        // Avoid returning cached context if we're in the process of resolving a context from the current route
        if (this.isSettingFromRoute) {
            return null;
        }
        const value = this.toObject();
        return value ? value.current : null;
    }
    getHistory() {
        const value = this.toObject();
        return value && value.history ? value.history : [];
    }
    async getCurrentContextAsync() {
        // Avoid returning cached context if we're in the process of resolving a context from the current route
        if (this.isSettingFromRoute) {
            return null;
        }
        const currentContext = await this.getAsync('current');
        if (!currentContext) {
            return null;
        }
        try {
            const contextResponse = await this.contextClient.getContextAsync(currentContext.id);
            return contextResponse.data;
        }
        catch (_a) {
            return null;
        }
    }
    async exchangeContextAsync(currentContext, ...requiredTypes) {
        try {
            const result = await this.contextClient.getRelatedContexts(currentContext.id, ...requiredTypes);
            return result.data;
        }
        catch (_a) {
            return [];
        }
    }
    async exchangeCurrentContextAsync(...requiredType) {
        const currentContext = await this.getCurrentContextAsync();
        if (currentContext === null) {
            return [];
        }
        return await this.exchangeContextAsync(currentContext, ...requiredType);
    }
    async setCurrentContextFromIdAsync(contextId) {
        this.isSettingFromRoute = true;
        try {
            const response = await this.contextClient.getContextAsync(contextId);
            const context = response.data;
            if (context) {
                this.isSettingFromRoute = false;
                await this.setCurrentContextAsync(context);
            }
        }
        catch (_a) {
            this.isSettingFromRoute = false;
        }
    }
}
const useContextManager = () => {
    const fusionContext = useFusionContext();
    return fusionContext.contextManager;
};
const useCurrentContextTypes = () => {
    const app = useCurrentApp();
    return app && app.context ? app.context.types : [];
};
const useContextHistory = () => {
    const contextManager = useContextManager();
    const [history, setHistory] = useState(contextManager.getHistory());
    const setHistoryFromCache = useCallback((contextCache) => {
        if (contextCache.history !== history) {
            setHistory(contextCache.history || []);
        }
    }, []);
    useEffect(() => {
        contextManager.toObjectAsync().then(setHistoryFromCache);
        return contextManager.on('change', setHistoryFromCache);
    }, []);
    return history;
};
const useCurrentContext = () => {
    const contextManager = useContextManager();
    const [currentContext, setCurrentContext] = useState(contextManager.getCurrentContext());
    const setContext = useCallback((contextCache) => {
        if (contextCache.current !== currentContext) {
            setCurrentContext(contextCache.current);
        }
    }, [currentContext]);
    useEffect(() => {
        contextManager.toObjectAsync().then(setContext);
        return contextManager.on('change', setContext);
    }, []);
    return currentContext || null;
};
const useContextQuery = () => {
    const [contexts, setContexts] = useState([]);
    const [queryText, setQueryText] = useState('');
    const [isQuerying, setIsQuerying] = useState(false);
    const [error, setError] = useState(null);
    const apiClients = useApiClients();
    const currentTypes = useCurrentContextTypes();
    const canQueryWithText = (text) => !!text && text.length > 2;
    const fetchContexts = useCallback(async (query) => {
        if (canQueryWithText(query)) {
            setContexts([]);
            try {
                const response = await apiClients.context.queryContextsAsync(query, ...currentTypes);
                setContexts(response.data);
                setIsQuerying(false);
            }
            catch (e) {
                setError(e);
                setContexts([]);
                setIsQuerying(false);
            }
        }
    }, [currentTypes]);
    useDebouncedAbortable(fetchContexts, queryText);
    const search = (query) => {
        setIsQuerying(canQueryWithText(query));
        setQueryText(query);
    };
    return { error, isQuerying, contexts, search };
};
export { useContextManager, useCurrentContext, useContextQuery, useCurrentContextTypes, useContextHistory, };

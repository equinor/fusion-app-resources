import { useFusionContext } from './FusionContext';
import * as React from 'react';
import EventEmitter, { useEventEmitter } from '../utils/EventEmitter';
import DistributedState from '../utils/DistributedState';
import useCurrentUser from '../auth/useCurrentUser';
export default class PeopleContainer extends EventEmitter {
    constructor(apiClients, resourceCollections, eventHub) {
        super();
        this.persons = {};
        this.images = {};
        this.peopleClient = apiClients.people;
        this.resourceCollection = resourceCollections.people;
        this.eventHub = eventHub;
    }
    getPersonDetails(personId) {
        if (this.persons[personId]) {
            return this.persons[personId].state;
        }
        return null;
    }
    async getPersonDetailsAsync(personId) {
        const cachedPerson = this.persons[personId];
        if (cachedPerson) {
            return cachedPerson.state;
        }
        const response = await this.peopleClient.getPersonDetailsAsync(personId, [
            'positions',
            'contracts',
            'roles',
        ]);
        this.persons[personId] = new DistributedState(`PeopleContainer.person.${personId}`, response.data, this.eventHub);
        this.persons[personId].on('change', (personDetails) => {
            this.emit('updated', personDetails);
        });
        return this.persons[personId].state;
    }
    async setRoleStatusForUser(personId, roleName, isActive) {
        const response = await this.peopleClient.setRoleStatusForUser(personId, roleName, isActive);
        if (!this.persons[personId] || !this.persons[personId].state.roles)
            return response.data;
        const person = this.persons[personId].state;
        const roles = person.roles;
        if (roles) {
            const newRoles = roles.map((role) => (role.name === roleName ? response.data : role));
            this.persons[personId].state = Object.assign(Object.assign({}, person), { roles: newRoles });
        }
        return response.data;
    }
    getPersonImage(personId) {
        if (this.images[personId]) {
            return this.images[personId].state;
        }
        return null;
    }
    async getPersonImageAsync(personId) {
        const cachedImage = this.images[personId];
        if (cachedImage) {
            return cachedImage.state;
        }
        return new Promise((resolve, reject) => {
            const urlToImage = `/images/profiles/${personId}`;
            const image = new Image();
            image.src = urlToImage;
            image.onerror = () => reject(`Could not load image ${urlToImage}.`);
            image.onload = () => {
                this.images[personId] = new DistributedState(`PeopleContainer.Images.${personId}`, image, this.eventHub);
                resolve(image);
            };
        });
    }
}
const usePeopleContainer = () => {
    const { peopleContainer } = useFusionContext();
    return peopleContainer;
};
const usePersonDetails = (personId) => {
    const peopleContainer = usePeopleContainer();
    const [isFetching, setFetching] = React.useState(false);
    const [error, setError] = React.useState(null);
    const [personDetails, setPersonDetails] = React.useState(peopleContainer.getPersonDetails(personId));
    const getPersonAsync = async (personId) => {
        if (!personId) {
            return;
        }
        try {
            setFetching(true);
            const personDetails = await peopleContainer.getPersonDetailsAsync(personId);
            setPersonDetails(personDetails);
            setFetching(false);
        }
        catch (error) {
            setError(error);
            setPersonDetails(null);
            setFetching(false);
        }
    };
    React.useEffect(() => {
        getPersonAsync(personId);
    }, [personId]);
    const updatedPersonHandler = React.useCallback((updatedPerson) => {
        if (personId === updatedPerson.azureUniqueId) {
            setPersonDetails(updatedPerson);
        }
    }, [personId]);
    useEventEmitter(peopleContainer, 'updated', updatedPersonHandler);
    return { isFetching, error, personDetails };
};
const usePersonImageUrl = (personId) => {
    const peopleContainer = usePeopleContainer();
    const getCachedPersonImageUrl = React.useCallback((personId) => {
        const personImage = peopleContainer.getPersonImage(personId);
        if (personImage) {
            return personImage.src;
        }
        return '';
    }, []);
    const [isFetching, setFetching] = React.useState(false);
    const [error, setError] = React.useState(null);
    const [imageUrl, setImageUrl] = React.useState(getCachedPersonImageUrl(personId));
    const getImageAsync = async (personId) => {
        if (!personId) {
            return;
        }
        const cachedImageUrl = getCachedPersonImageUrl(personId);
        if (cachedImageUrl !== '') {
            setImageUrl(cachedImageUrl);
            return;
        }
        try {
            setFetching(true);
            const image = await peopleContainer.getPersonImageAsync(personId);
            setImageUrl(image.src);
            setFetching(false);
        }
        catch (error) {
            setFetching(false);
            setError(error);
            setImageUrl('');
        }
    };
    React.useEffect(() => {
        getImageAsync(personId);
    }, [personId]);
    return { isFetching, error, imageUrl };
};
const useCurrentPersonDetails = () => {
    const currentUser = useCurrentUser();
    return usePersonDetails((currentUser === null || currentUser === void 0 ? void 0 : currentUser.id) || '');
};
export { usePeopleContainer, usePersonDetails, usePersonImageUrl, useCurrentPersonDetails };

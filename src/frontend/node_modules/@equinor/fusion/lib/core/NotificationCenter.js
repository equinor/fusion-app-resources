import React, { useState, useEffect } from 'react';
import uuid from 'uuid/v1';
import ReliableDictionary, { LocalStorageProvider } from '../utils/ReliableDictionary';
import { useEventEmitterValue } from '../utils/EventEmitter';
import { useFusionContext } from './FusionContext';
import DistributedState from '../utils/DistributedState';
import EventHub from '../utils/EventHub';
import useSignalRHub from '../hooks/useSignalRHub';
export default class NotificationCenter extends ReliableDictionary {
    constructor(eventHub, apiClients) {
        super(new LocalStorageProvider('NOTIFICATION_CENTER', new EventHub(), { notifications: [] }));
        this.notificationCards = new DistributedState('NotificationCenter.NotificationCards', [], eventHub);
        this.presenters = new DistributedState('NotificationCenter.presenters', [], eventHub);
        this.cardPresenter = new DistributedState('NotificationCenter.cardPresenter', null, eventHub);
        this.notificationClient = apiClients.notification;
    }
    async sendAsync(notificationRequest, notificationContext) {
        if (!(await this.shouldPresentNotificationAsync(notificationRequest))) {
            return Promise.reject();
        }
        const notification = this.createNotification(notificationRequest);
        await this.persistAsync(notification);
        const response = await this.presentAsync(notification, notificationContext);
        if (response.confirmed) {
            this.emit('confirmed', notificationRequest);
        }
        else if (response.dismissed) {
            this.emit('dismissed', notificationRequest);
        }
        else if (response.cancelled) {
            this.emit('cancelled', notificationRequest);
        }
        this.emit('finished', notificationRequest);
        const notificationWithResponse = Object.assign(Object.assign({}, notification), { responded: new Date(), response });
        await this.persistAsync(notificationWithResponse);
        return response;
    }
    sendCard(notificationCard, notificationContext, silent) {
        this.mergeNotificationCards([notificationCard]);
        !silent && this.presentCardAsync(notificationCard, notificationContext);
    }
    presentCardAsync(notification, notificationContext) {
        const presenter = this.getCardPresenter(notificationContext);
        if (!presenter) {
            throw new Error('No presenter for notification cards ');
        }
        presenter.present(notification);
    }
    async getNotificationCardsAsync(filter) {
        const response = await this.notificationClient.getPersonNotificationsAsync('me', filter);
        this.mergeNotificationCards(response.data.value);
        return response.data.value;
    }
    mergeNotificationCards(cards) {
        const newNotificationCards = cards.filter((t) => !this.notificationCards.state.find((e) => e.id === t.id));
        const mergedNotificationCards = [...this.notificationCards.state, ...newNotificationCards];
        this.notificationCards.state = mergedNotificationCards.map((c) => cards.find((n) => n.id === c.id) || c);
        this.emit('notification-cards-updated', this.notificationCards.state);
    }
    deleteNotificationCards(cards) {
        this.notificationCards.state = [...this.notificationCards.state].filter((c) => !cards.some((deletedCard) => deletedCard.id === c.id));
        this.emit('notification-cards-updated', this.notificationCards.state);
    }
    getNotificationCards() {
        return [...this.notificationCards.state];
    }
    registerCardPresenter(present) {
        const notificationPresenter = {
            present,
        };
        this.cardPresenter.state = notificationPresenter;
        return () => {
            this.cardPresenter.state = null;
        };
    }
    async markNotificationCardAsSeenAsync(notificationCard) {
        const payload = {
            seenByUser: true,
        };
        const response = await this.notificationClient.updateNotificationAsync(notificationCard.id, payload);
        this.mergeNotificationCards([response.data]);
        return response.data;
    }
    async deleteNotificationCardAsync(notificationCard) {
        await this.notificationClient.deleteNotificationAsync(notificationCard.id);
        this.deleteNotificationCards([notificationCard]);
        return;
    }
    registerPresenter(level, present) {
        const notificationPresenter = {
            level,
            present,
        };
        this.presenters.state = [...this.presenters.state, notificationPresenter];
        return () => {
            this.presenters.state = this.presenters.state.filter((p) => p !== notificationPresenter);
        };
    }
    async getAllNotificationsAsync() {
        const notifications = await this.getAsync('notifications');
        return notifications || [];
    }
    async shouldPresentNotificationAsync(notificationRequest) {
        const allNotifications = await this.getAllNotificationsAsync();
        if (allNotifications.find((n) => n.responded !== null && n.id === notificationRequest.id)) {
            return false;
        }
        return true;
    }
    createNotification(notificationRequest) {
        return {
            id: notificationRequest.id || uuid(),
            request: notificationRequest,
            response: null,
            presented: new Date(),
            responded: null,
            timeout: this.getTimeoutForLevel(notificationRequest),
        };
    }
    getTimeoutForLevel(notificationRequest) {
        switch (notificationRequest.level) {
            case 'low':
                return notificationRequest.timeout
                    ? Math.max(4000, Math.min(10000, notificationRequest.timeout))
                    : 4000;
            default:
                return null;
        }
    }
    async persistAsync(notification) {
        if (notification.request.level === 'low') {
            return;
        }
        const notifications = await this.getAllNotificationsAsync();
        const existing = notifications.find((n) => n.id === notification.id);
        if (!existing) {
            await this.setAsync('notifications', [...notifications, notification]);
        }
        else {
            await this.setAsync('notifications', notifications.map((n) => (n.id === notification.id ? notification : n)));
        }
    }
    presentAsync(notification, notificationContext) {
        const presenter = this.getPresenter(notification.request, notificationContext);
        if (!presenter) {
            throw new Error('No presenter for notification level ' + notification.request.level);
        }
        const abortController = new AbortController();
        return new Promise((resolve, reject) => {
            // Dismiss the notification after timeout if specified
            if (notification.timeout) {
                setTimeout(() => {
                    abortController.abort();
                }, notification.timeout);
            }
            try {
                presenter.present(notification.request, resolve, abortController.signal);
                this.emit('presented', notification.request);
            }
            catch (e) {
                reject(e);
            }
        });
    }
    getCardPresenter(notificationContext) {
        const contextualPresenter = notificationContext === null || notificationContext === void 0 ? void 0 : notificationContext.cardPresenter;
        return contextualPresenter || this.cardPresenter.state;
    }
    getPresenter(notification, notificationContext) {
        var _a;
        const contextualPresenter = (_a = notificationContext === null || notificationContext === void 0 ? void 0 : notificationContext.presenters) === null || _a === void 0 ? void 0 : _a.find((presenter) => presenter.level === notification.level);
        return (contextualPresenter ||
            this.presenters.state.find((presenter) => presenter.level === notification.level));
    }
}
const NotificationContext = React.createContext({});
export const NotificationContextProvider = ({ children }) => {
    const [presenters, setPresenters] = React.useState([]);
    const [cardPresenter, setCardPresenter] = React.useState(null);
    const registerPresenter = React.useCallback((level, present) => {
        const notificationPresenter = {
            level,
            present,
        };
        setPresenters((p) => [notificationPresenter, ...p]);
        return () => {
            setPresenters((p) => p.filter((presenter) => presenter !== notificationPresenter));
        };
    }, []);
    const registerCardPresenter = React.useCallback((present) => {
        const notificationPresenter = {
            present,
        };
        setCardPresenter(notificationPresenter);
        return () => {
            setCardPresenter(null);
        };
    }, []);
    return (React.createElement(NotificationContext.Provider, { value: { presenters, registerPresenter, cardPresenter, registerCardPresenter } }, children));
};
export const useNotificationContext = () => React.useContext(NotificationContext);
export const useNotificationCenter = () => {
    const { notificationCenter } = useFusionContext();
    const notificationContext = React.useContext(NotificationContext);
    return (notificationRequest) => notificationCenter.sendAsync(notificationRequest, notificationContext);
};
export const useNotificationCards = () => {
    const { notificationCenter } = useFusionContext();
    const defaultData = notificationCenter.getNotificationCards();
    const { hubConnection } = useSignalRHub('notifications');
    const [error, setError] = useState(null);
    const [isFetchingUnRead, setIsFetchingUnRead] = useState(false);
    const [isFetchingRead, setIsFetchingRead] = useState(false);
    const [notificationCards, setNotificationCards] = useEventEmitterValue(notificationCenter, 'notification-cards-updated', (n) => n, defaultData);
    const sendNotification = React.useCallback((notification) => {
        notificationCenter.sendCard(notification);
    }, [notificationCenter]);
    const getUnReadNotificationCardsAsync = async () => {
        setIsFetchingUnRead(true);
        try {
            const filterFromDate = new Date(new Date().getTime() - 24 * 60 * 60 * 1000 * 30).toISOString();
            //30 days from today
            const filter = `created gt ${filterFromDate} and seenByUser eq false`;
            const data = await notificationCenter.getNotificationCardsAsync(filter);
            setNotificationCards(data);
        }
        catch (e) {
            setError(e);
        }
        setIsFetchingUnRead(false);
    };
    const getReadNotificationCardsAsync = async () => {
        setIsFetchingRead(true);
        try {
            const data = await notificationCenter.getNotificationCardsAsync('seenByUser eq true');
            setNotificationCards(data);
        }
        catch (e) {
            setError(e);
        }
        setIsFetchingRead(false);
    };
    useEffect(() => {
        getUnReadNotificationCardsAsync();
    }, []);
    useEffect(() => {
        if (hubConnection) {
            hubConnection.on('notifications', sendNotification);
            return () => hubConnection.off('notifications', sendNotification);
        }
    }, [hubConnection]);
    return {
        notificationCards,
        isFetchingRead,
        isFetchingUnRead,
        error,
        getReadNotificationCardsAsync,
    };
};
export const useGlobalNotificationCardsActions = () => {
    const { notificationCenter } = useFusionContext();
    const [isMarkingNotifications, setIsMarkingNotifications] = React.useState(false);
    const [markError, setMarkError] = React.useState(null);
    const markNotificationsAsSeenAsync = React.useCallback(async (notificationCards) => {
        setIsMarkingNotifications(true);
        setMarkError(null);
        try {
            const response = notificationCards.map((card) => notificationCenter.markNotificationCardAsSeenAsync(card));
            await Promise.all(response);
        }
        catch (e) {
            setMarkError(e);
        }
        finally {
            setIsMarkingNotifications(false);
        }
    }, [notificationCenter]);
    return {
        markNotificationsAsSeenAsync,
        isMarkingNotifications,
        markError,
    };
};
export const useNotificationCardActions = (notificationCard) => {
    const { notificationCenter } = useFusionContext();
    const notificationContext = useNotificationContext();
    const [isMarkingNotification, setIsMarkingNotification] = React.useState(false);
    const [markError, setMarkError] = React.useState(null);
    const [isDeletingNotification, setIsDeletingNotification] = React.useState(false);
    const [deleteError, setDeleteError] = React.useState(null);
    const markNotificationsAsSeenAsync = React.useCallback(async () => {
        setIsMarkingNotification(true);
        setMarkError(null);
        try {
            await notificationCenter.markNotificationCardAsSeenAsync(notificationCard);
        }
        catch (e) {
            setMarkError(e);
        }
        finally {
            setIsMarkingNotification(false);
        }
    }, [notificationCenter, notificationCard]);
    const deleteNotificationAsync = React.useCallback(async () => {
        setIsDeletingNotification(true);
        setDeleteError(null);
        try {
            await notificationCenter.deleteNotificationCardAsync(notificationCard);
        }
        catch (e) {
            setDeleteError(e);
        }
        finally {
            setIsDeletingNotification(false);
        }
    }, [notificationCenter, notificationCard]);
    const deleteNotificationCard = React.useCallback(async () => {
        const notificationRequest = {
            level: 'high',
            title: 'You are about to permanently delete this notification',
            confirmLabel: 'Delete notification',
            cancelLabel: 'Dismiss',
        };
        const response = await notificationCenter.sendAsync(notificationRequest, notificationContext);
        if (response.confirmed) {
            await deleteNotificationAsync();
        }
    }, [notificationContext, notificationCenter]);
    return {
        markNotificationsAsSeenAsync,
        isMarkingNotification,
        markError,
        deleteNotificationCard,
        isDeletingNotification,
        deleteError,
    };
};

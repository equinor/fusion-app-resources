import AuthApp from './AuthApp';
import AuthToken from './AuthToken';
import AuthNonce from './AuthNonce';
import AuthCache from './AuthCache';
import AuthUser from './AuthUser';
import { trimTrailingSlash } from '../utils/url';
export class FusionAuthAppNotFoundError extends Error {
    constructor(clientId) {
        super(`Unable to find app for client id [${clientId}]`);
    }
}
export class FusionAuthLoginError extends Error {
}
const getTopLevelWindow = (win) => {
    if (win === win.parent) {
        return win;
    }
    return getTopLevelWindow(win.parent);
};
export default class AuthContainer {
    constructor() {
        this.cachedUser = null;
        this._tokenQueue = {};
        this.apps = [];
        this.cache = new AuthCache();
    }
    async handleWindowCallbackAsync() {
        const token = AuthContainer.getTokenFromHash(window.location.hash);
        const error = AuthContainer.getErrorFromHash(window.location.hash);
        if (error) {
            const authError = new FusionAuthLoginError(error);
            this.logError(authError);
            throw authError;
        }
        if (token === null) {
            return;
        }
        try {
            const parsedToken = AuthToken.parse(token);
            const nonce = AuthNonce.resolve(parsedToken.nonce);
            const clientId = nonce.toString();
            const app = new AuthApp(clientId, []);
            this.apps.push(app);
            await this.updateTokenForAppAsync(app, token);
            window.location.hash = '';
            const redirectUrl = await this.cache.getRedirectUrl();
            if (redirectUrl &&
                AuthContainer.getResourceOrigin(redirectUrl) === window.location.origin) {
                window.history.replaceState(null, '', redirectUrl);
                window.location.reload(true);
            }
        }
        catch (e) {
            this.logError(e);
            throw new FusionAuthLoginError();
        }
    }
    async _acquireTokenAsync(app, resource) {
        try {
            // try to use previous token (if any and not expired)
            const cachedToken = await this.cache.getTokenAsync(app);
            if (cachedToken !== null && cachedToken.isValid()) {
                return cachedToken.toString();
            }
            // clear previous token for app
            await this.cache.clearTokenAsync(app);
            const refreshedToken = await this.refreshTokenAsync(resource);
            if (!refreshedToken) {
                throw Error('invalid token');
            }
            // add new token to cache for app
            await this.updateTokenForAppAsync(app, refreshedToken);
            return refreshedToken;
        }
        catch (err) {
            console.log(err);
            // failed to acquire new token
            return null;
        }
        finally {
            // remove request from queue
            delete this._tokenQueue[app.clientId];
        }
    }
    acquireTokenAsync(resource) {
        const app = this.resolveApp(resource);
        if (app === null) {
            throw new FusionAuthAppNotFoundError(resource);
        }
        /**
         * since acquiring token is async we need to make sure that only
         * one thread is clearing old token and acquires a new one
         */
        if (!this._tokenQueue[app.clientId]) {
            this._tokenQueue[app.clientId] = this._acquireTokenAsync(app, resource);
        }
        return this._tokenQueue[app.clientId];
    }
    async refreshTokenAsync(resource) {
        // TODO: This should refresh the token instead of logging in
        // For now this is not possible because of iframes and crazy stuff
        await this.loginAsync(resource);
        return null;
    }
    async registerAppAsync(clientId, resources) {
        resources = resources.filter(Boolean);
        const existingApp = this.resolveApp(clientId);
        if (existingApp !== null) {
            existingApp.updateResources(resources);
            const cachedToken = await this.cache.getTokenAsync(existingApp);
            if (cachedToken === null) {
                return false;
            }
            await this.cache.clearAppLoginLock(existingApp.clientId);
            return true;
        }
        const newApp = new AuthApp(clientId, resources);
        this.apps.push(newApp);
        const cachedToken = await this.cache.getTokenAsync(newApp);
        if (cachedToken !== null) {
            await this.cache.clearAppLoginLock(newApp.clientId);
            return true;
        }
        return false;
    }
    async loginAsync(clientId) {
        const app = this.resolveApp(clientId);
        if (app === null) {
            throw new FusionAuthAppNotFoundError(clientId);
        }
        const isLocked = await this.cache.isAppLoginLocked();
        if (isLocked) {
            return;
        }
        await this.cache.setAppLoginLock(app.clientId);
        const nonce = AuthNonce.createNew(app);
        this.cache.storeRedirectUrl(getTopLevelWindow(window).location.href);
        // Login page cannot be displayed within a frame
        // Get the top level window and redirect there
        getTopLevelWindow(window).location.href = await this.buildLoginUrlAsync(app, nonce);
    }
    async logoutAsync(clientId) {
        if (clientId) {
            const app = this.resolveApp(clientId);
            if (app === null) {
                throw new FusionAuthAppNotFoundError(clientId);
            }
            return await this.cache.clearTokenAsync(app);
        }
        await this.cache.clearAsync();
        // TODO: Redirect to sign out page to clear cookies?
    }
    async getCachedUserAsync() {
        if (!this.cachedUser) {
            this.cachedUser = await this.cache.getUserAsync();
        }
        return this.cachedUser;
    }
    getCachedUser() {
        return this.cachedUser || null;
    }
    setTelemetryLogger(telemetryLogger) {
        this.telemetryLogger = telemetryLogger;
    }
    logError(error) {
        if (this.telemetryLogger) {
            this.telemetryLogger.trackException({ error });
        }
    }
    async updateTokenForAppAsync(app, token) {
        const parsedToken = AuthToken.parse(token);
        await this.cache.storeTokenAsync(app, parsedToken);
        const cachedUser = (await this.getCachedUserAsync()) || AuthUser.createFromToken(parsedToken);
        cachedUser.mergeWithToken(parsedToken);
        await this.cacheUserAsync(cachedUser);
    }
    async cacheUserAsync(user) {
        this.cachedUser = user;
        await this.cache.storeUserAsync(user);
    }
    static getResourceOrigin(resource) {
        try {
            const url = new URL(resource);
            return trimTrailingSlash(url.origin.toLowerCase());
        }
        catch (_a) {
            return '';
        }
    }
    static getTokenFromHash(hash) {
        return AuthContainer.getPartFromHash(hash, 'id_token');
    }
    static getErrorFromHash(hash) {
        return AuthContainer.getPartFromHash(hash, 'error');
    }
    static getPartFromHash(hash, key) {
        const parts = hash.substr(1).split('&');
        const tokenPart = parts.find((part) => part.indexOf(`${key}=`) === 0);
        if (typeof tokenPart === 'undefined') {
            return null;
        }
        return tokenPart.replace(`${key}=`, '');
    }
    async buildLoginUrlAsync(app, nonce, customParams = {}) {
        const cachedUser = await this.getCachedUserAsync();
        const base = 'https://login.microsoftonline.com/3aa4a235-b6e2-48d5-9195-7fcf05b459b0/oauth2/authorize';
        const params = Object.assign(Object.assign({}, customParams), { client_id: app.clientId, response_type: 'id_token', redirect_uri: getTopLevelWindow(window).location.origin.split('#')[0], nonce: nonce.getKey(), login_hint: cachedUser ? cachedUser.upn : null });
        const queryString = Object.keys(params)
            .filter((key) => params[key])
            .reduce((query, key) => query + `${query ? '&' : ''}${key}=${encodeURIComponent(params[key])}`, '');
        return base + '?' + queryString;
    }
    resolveApp(resource) {
        const resourceOrigin = AuthContainer.getResourceOrigin(resource);
        const app = this.apps.find((app) => app.resources.some((r) => r === resource) ||
            app.resources.indexOf(resourceOrigin) !== -1 ||
            app.clientId === resourceOrigin ||
            app.clientId === resource);
        if (typeof app === 'undefined') {
            return null;
        }
        return app;
    }
}

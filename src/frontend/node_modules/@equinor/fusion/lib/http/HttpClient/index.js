import uuid from 'uuid/v1';
import { HttpClientError, HttpClientParseError, HttpClientRequestFailedError, } from './HttpClientError';
import ensureRequestInit from './ensureRequestInit';
import { useFusionContext } from '../../core/FusionContext';
import JSON from '../../utils/JSON';
import DistributedState from '../../utils/DistributedState';
// Export interface, response and error types
export { HttpClientError, HttpClientParseError, HttpClientRequestFailedError, };
export const voidResponseParser = () => Promise.resolve();
export default class HttpClient {
    constructor(authContainer, resourceCache, abortControllerManager, telemetryLogger, eventHub) {
        this.sessionId = uuid();
        this.authContainer = authContainer;
        this.resourceCache = resourceCache;
        this.abortControllerManager = abortControllerManager;
        this.telemetryLogger = telemetryLogger;
        this.requestsInProgress = new DistributedState('FusionHttpClient.requestsInProgress', {}, eventHub);
    }
    async getAsync(url, init, responseParser) {
        // Reuse GET requests in progress
        const requestInProgress = this.getRequestInProgress(url);
        if (requestInProgress) {
            return await requestInProgress;
        }
        return this.performReusableRequest(url, async () => {
            await this.resourceCache.setIsFetchingAsync(url);
            init = ensureRequestInit(init, (init) => (Object.assign(Object.assign({}, init), { method: 'GET' })));
            const response = await this.performFetchAsync(url, init);
            const data = await this.parseResponseAsync(init, response, responseParser);
            await this.resourceCache.updateAsync(url, data);
            return data;
        });
    }
    async postAsync(url, body, init, responseParser) {
        init = ensureRequestInit(init, (init) => (Object.assign(Object.assign({}, init), { method: 'POST', body: this.createRequestBody(body) })));
        const response = await this.performFetchAsync(url, init);
        return await this.parseResponseAsync(init, response, responseParser);
    }
    async putAsync(url, body, init, responseParser) {
        init = ensureRequestInit(init, (init) => (Object.assign(Object.assign({}, init), { method: 'PUT', body: this.createRequestBody(body) })));
        const response = await this.performFetchAsync(url, init);
        return await this.parseResponseAsync(init, response, responseParser);
    }
    async patchAsync(url, body, init, responseParser) {
        init = ensureRequestInit(init, (init) => (Object.assign(Object.assign({}, init), { method: 'PATCH', body: this.createRequestBody(body) })));
        const response = await this.performFetchAsync(url, init);
        return await this.parseResponseAsync(init, response, responseParser);
    }
    async deleteAsync(url, init, responseParser) {
        init = ensureRequestInit(init, (init) => (Object.assign(Object.assign({}, init), { method: 'DELETE' })));
        const response = await this.performFetchAsync(url, init);
        return await this.parseResponseAsync(init, response, responseParser);
    }
    async optionsAsync(url, init, responseParser) {
        init = ensureRequestInit(init, (init) => (Object.assign(Object.assign({}, init), { method: 'OPTIONS' })));
        const response = await this.performFetchAsync(url, init);
        return await this.parseResponseAsync(init, response, responseParser);
    }
    async postFormAsync(url, form, onProgress, responseParser) {
        const token = await this.authContainer.acquireTokenAsync(url);
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            if (onProgress) {
                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const percentage = Math.round((e.loaded * 100) / e.total);
                        onProgress(percentage, e);
                    }
                });
            }
            xhr.addEventListener('load', () => {
                const headerLines = xhr.getAllResponseHeaders();
                const headers = headerLines.trim().split(/[\r\n]+/);
                const headerMap = headers.reduce((headerMap, line) => {
                    const parts = line.split(': ');
                    const header = parts.shift();
                    const value = parts.join(': ');
                    if (header)
                        headerMap.append(header, value);
                    return headerMap;
                }, new Headers());
                const response = {
                    data: responseParser
                        ? responseParser(xhr.responseText)
                        : JSON.parse(xhr.responseText),
                    status: xhr.status,
                    headers: headerMap,
                    refreshRequest: null,
                };
                resolve(response);
            });
            xhr.upload.addEventListener('error', () => {
                const response = xhr.responseText;
                if (response) {
                    const errorResponse = JSON.parse(response);
                    reject(new HttpClientRequestFailedError(url, xhr.status, errorResponse));
                }
                reject(new HttpClientRequestFailedError(url, xhr.status, null));
            });
            xhr.open('POST', url, true);
            xhr.setRequestHeader('X-Session-Id', this.sessionId);
            xhr.setRequestHeader('Accept', 'application/json');
            xhr.setRequestHeader('x-pp-refresh', 'true');
            xhr.setRequestHeader('Authorization', 'Bearer ' + token);
            xhr.send(form);
        });
    }
    async getBlobAsync(url, init) {
        if (!init) {
            init = {
                headers: new Headers({ Accept: '*/*' }),
            };
        }
        init = ensureRequestInit(init, (init) => (Object.assign(Object.assign({}, init), { method: 'GET' })));
        const response = await this.performFetchAsync(url, init);
        const blob = await response.blob();
        const fileName = this.resolveFileNameFromHeader(response);
        if (!fileName) {
            throw new Error('Cannot download file without filename');
        }
        return { blob, fileName };
    }
    async getFileAsync(url, init) {
        if (!init) {
            init = {
                headers: new Headers({ Accept: '*/*' }),
            };
        }
        init = ensureRequestInit(init, (init) => (Object.assign(Object.assign({}, init), { method: 'GET' })));
        const response = await this.performFetchAsync(url, init);
        const blob = await response.blob();
        const fileName = this.resolveFileNameFromHeader(response);
        if (!fileName) {
            throw new Error('Cannot download file without filename');
        }
        return new File([blob], fileName);
    }
    responseIsRetriable(response, retryTimeout) {
        if (retryTimeout > 20000 || response.headers.get('x-fusion-retriable') === 'false') {
            return false;
        }
        return (response.status === 408 ||
            response.status === 424 ||
            (response.status === 500 && response.headers.get('x-fusion-retriable') === 'true') ||
            response.status === 502 ||
            response.status === 503 ||
            response.status === 504);
    }
    async retryRequestAsync(url, init, retryTimeout) {
        var _a;
        // Wait before retrying the request
        await new Promise((resolve) => setTimeout(resolve, retryTimeout));
        // Abort the request if the signal has been aborted while waiting
        if ((_a = this.abortControllerManager.getCurrentSignal()) === null || _a === void 0 ? void 0 : _a.aborted) {
            throw new Error(`Request ${init.method} ${url} was aborted`);
        }
        return this.performFetchAsync(url, init, retryTimeout + 3000);
    }
    async performFetchAsync(url, init, retryTimeout = 3000) {
        try {
            const options = await this.transformRequestAsync(url, init);
            const response = await fetch(url, options);
            if (!response.ok) {
                if (this.responseIsRetriable(response, retryTimeout)) {
                    return this.retryRequestAsync(url, init, retryTimeout);
                }
                // Add more info
                const errorResponse = await this.parseResponseJSONAsync(response);
                throw new HttpClientRequestFailedError(url, response.status, errorResponse);
            }
            return response;
        }
        catch (error) {
            if (error instanceof HttpClientRequestFailedError) {
                // TODO: Add to notification center?
                // TODO: Update cache status?
                throw error;
            }
            this.telemetryLogger.trackException({ exception: error });
            // Add more info
            throw error;
        }
    }
    async performReusableRequest(url, handler) {
        // Reuse GET requests in progress
        const requestInProgress = this.getRequestInProgress(url);
        if (requestInProgress) {
            return await requestInProgress;
        }
        const requestPerformer = async () => {
            try {
                const data = await handler();
                const requestsInProgres = this.requestsInProgress.state;
                delete requestsInProgres[url];
                this.requestsInProgress.state = Object.assign({}, requestsInProgres);
                return data;
            }
            catch (error) {
                const requestsInProgres = this.requestsInProgress.state;
                delete requestsInProgres[url];
                this.requestsInProgress.state = Object.assign({}, requestsInProgres);
                throw error;
            }
        };
        const request = requestPerformer();
        this.requestsInProgress.state = Object.assign(Object.assign({}, this.requestsInProgress.state), { [url]: request });
        return await request;
    }
    // Response parsers
    async parseResponseJSONAsync(response) {
        try {
            const text = await response.text();
            const json = text ? JSON.parse(text) : null;
            return json;
        }
        catch (parseError) {
            // Add more info
            throw new HttpClientParseError(response);
        }
    }
    async parseResponseAsync(request, response, responseParser) {
        const data = responseParser
            ? await responseParser(response)
            : await this.parseResponseJSONAsync(response);
        // TODO: Update cache status?
        // TODO: response should hint of null or throw empty response error, too big for current fix scope
        return this.createHttpResponse(request, response, data);
    }
    createHttpResponse(request, response, data) {
        const httpResponse = {
            data,
            status: response.status,
            headers: response.headers,
            refreshRequest: null,
        };
        if (this.responseIsRefreshable(response)) {
            const refreshRequest = this.addRefreshHeader(request);
            return Object.assign(Object.assign({}, httpResponse), { refreshRequest });
        }
        return httpResponse;
    }
    responseIsRefreshable(response) {
        return response.headers.get('x-pp-is-refreshable') !== null;
    }
    // Request transformers
    async transformRequestAsync(url, init) {
        const requestWithSessionId = this.addSessionIdHeader(init);
        const requestWithAcceptJson = this.addAcceptJsonHeader(requestWithSessionId);
        const requestWithAuthToken = await this.addAuthHeaderAsync(url, requestWithAcceptJson);
        const requestWithAbortSignal = this.addAbortSignal(requestWithAuthToken);
        return requestWithAbortSignal;
    }
    addSessionIdHeader(init) {
        return this.transformHeaders(init, (headers) => headers.append('X-Session-Id', this.sessionId));
    }
    addAcceptJsonHeader(init) {
        return this.transformHeaders(init, (headers) => headers.append('Accept', 'application/json'));
    }
    addRefreshHeader(init) {
        return this.transformHeaders(init, (headers) => headers.append('x-pp-refresh', 'true'));
    }
    async addAuthHeaderAsync(url, init) {
        const token = await this.authContainer.acquireTokenAsync(url);
        return this.transformHeaders(init, (headers) => headers.append('Authorization', 'Bearer ' + token));
    }
    addAbortSignal(init) {
        const signal = this.abortControllerManager.getCurrentSignal();
        if (signal !== null) {
            init.signal = signal;
        }
        return init;
    }
    transformHeaders(init, transform) {
        const headers = new Headers(init.headers);
        transform(headers);
        return Object.assign(Object.assign({}, init), { headers });
    }
    // Utils
    getRequestInProgress(url) {
        return this.requestsInProgress.state[url];
    }
    createRequestBody(body) {
        if (typeof body === 'function') {
            const bodyFactory = body;
            return bodyFactory();
        }
        return JSON.stringify(body);
    }
    resolveFileNameFromHeader(response) {
        const contentDisposition = response.headers.get('Content-Disposition');
        if (!contentDisposition)
            return null;
        const parts = contentDisposition.split(';');
        const fileNamePart = parts.find((part) => part.indexOf('filename=') !== -1);
        if (!fileNamePart)
            return null;
        const fileName = fileNamePart.split('=')[1];
        // The API returns filename wrapped in double qutoes to preserve spaces.
        // These should be replaced when parsing the filename to prevent the browser
        // from prefixing and postfixing the filname with underscores during download.
        // If we do not replace the quotes, the parsed filename would be a double quoted
        // string (e.g. ""file.pdf""). The browser would likely create the following
        // filename when the file is downloaded: _file.pdf_. This would result in the
        // client not recognising the file format and the user will not be able to open
        // the file.
        return fileName.replace(/["]/g, '');
    }
}
export const useHttpClient = () => {
    const { http } = useFusionContext();
    return http.client;
};

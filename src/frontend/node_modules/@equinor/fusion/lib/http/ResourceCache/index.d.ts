import { HttpResponse } from '../HttpClient';
import EventEmitter from '../../utils/EventEmitter';
import { IEventHub } from '../../utils/EventHub';
declare type CacheStatus = {
    age: Date | null;
    source: string | null;
    duration: number | null;
};
declare type CachedResource<T> = {
    resource: string;
    data: T | null;
    isFetching: boolean;
    cacheStatus: CacheStatus;
};
export declare type ReadonlyCachedResource<T> = Readonly<CachedResource<T>> & {
    data: Readonly<T> | null;
};
declare type ResourceCacheEvents = {
    update: <T>(changedResource: ReadonlyCachedResource<T>) => void;
};
export interface IResourceCache {
    setIsFetchingAsync<T>(resource: string): Promise<void>;
    updateAsync<T>(resource: string, response: HttpResponse<T>): Promise<void>;
    getAsync<T>(resource: string): Promise<ReadonlyCachedResource<T>>;
}
export default class ResourceCache extends EventEmitter<ResourceCacheEvents> implements IResourceCache {
    private cachedResources;
    constructor(eventHub: IEventHub);
    setIsFetchingAsync<T>(resource: string): Promise<void>;
    updateAsync<T>(resource: string, response: HttpResponse<T>): Promise<void>;
    getAsync<T>(resource: string): Promise<ReadonlyCachedResource<T>>;
    private setResourceAsync;
}
export {};

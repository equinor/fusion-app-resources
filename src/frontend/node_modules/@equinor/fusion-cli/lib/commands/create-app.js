"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const chalk = require("chalk");
const execa = require("execa");
const figlet = require("figlet");
const fs = require("fs");
const inquirer = require("inquirer");
const Listr = require("listr");
const ncp = require("ncp");
const path = require("path");
const pkg_install_1 = require("pkg-install");
const util_1 = require("util");
const access = util_1.promisify(fs.access);
const copy = util_1.promisify(ncp);
class CreateApp extends command_1.Command {
    async run() {
        const parsed = this.parse(CreateApp);
        console.log(figlet.textSync('Fusion', {
            font: '3D-ASCII',
            horizontalLayout: 'default',
            verticalLayout: 'default',
        }));
        const options = await promptForMissingOptions(parsed.flags);
        await createProject(options);
    }
}
exports.default = CreateApp;
CreateApp.description = 'Creates a new fusion app';
CreateApp.flags = {
    description: command_1.flags.string({ char: 'd', description: 'App description' }),
    git: command_1.flags.boolean({ char: 'g', description: 'Initialize git repository' }),
    help: command_1.flags.help({ char: 'h' }),
    install: command_1.flags.boolean({ char: 'i', description: 'Install dev dependencies' }),
    key: command_1.flags.string({ char: 'k', description: 'Key for app/tile' }),
    name: command_1.flags.string({ char: 'n', description: 'Name for app/tile(use quotes for spaces)' }),
    shortName: command_1.flags.string({ char: 'N', description: 'App short name' }),
    templateName: command_1.flags.string({ char: 't', description: 'App template to use' }),
    reportIdProd: command_1.flags.string({ char: 'R', description: 'Add reportId from production' }),
    reportIdTest: command_1.flags.string({ char: 'r', description: 'Add reportId from test(CI)' }),
};
const slugify = (text) => text
    .toLowerCase()
    .replace(/[^\w ]+/g, '')
    .replace(/ +/g, '-');
const promptForMissingOptions = async (options) => {
    const questions = [];
    const nameQuestion = [];
    const templateQuestion = [];
    if (!options.name || typeof options.name !== 'string') {
        nameQuestion.push({
            message: 'Please enter a app name',
            name: 'name',
            type: 'input',
        });
    }
    const selectedName = nameQuestion.length !== 0 ? await inquirer.prompt(nameQuestion) : options;
    if (!options.key) {
        questions.push({
            default: selectedName && slugify(selectedName.name),
            message: 'Please enter a app key',
            name: 'key',
            type: 'input',
        });
    }
    if (!options.shortName) {
        questions.push({
            default: selectedName.name,
            message: 'Please enter a app shortname',
            name: 'shortName',
            type: 'input',
        });
    }
    if (!options.description) {
        questions.push({
            default: '',
            message: 'Please enter a app description',
            name: 'description',
            type: 'input',
        });
    }
    if (!options.templateName) {
        templateQuestion.push({
            default: 'app',
            message: 'Please enter a app template (app | report)',
            name: 'template',
            type: 'input',
        });
    }
    const selectedTemplate = templateQuestion.length !== 0 ? await inquirer.prompt(templateQuestion) : options;
    if (selectedTemplate.template === 'report') {
        if (!options.reportIdProd) {
            questions.push({
                default: '',
                message: 'Please enter reportID for production',
                name: 'reportIdProd',
                type: 'input',
            });
        }
        if (!options.reportIdTest) {
            questions.push({
                default: '',
                message: 'Please enter reportID for test(CI)',
                name: 'reportIdTest',
                type: 'input',
            });
        }
    }
    if (!options.key) {
        questions.push({
            default: true,
            message: 'Initialize git?',
            name: 'git',
            type: 'confirm',
        });
    }
    if (!options.install) {
        questions.push({
            default: false,
            message: 'Install dependencies?',
            name: 'install',
            type: 'confirm',
        });
    }
    const answers = await inquirer.prompt(questions);
    return Object.assign(Object.assign({}, options), { description: options.description || answers.description, git: options.git || answers.git, install: options.install || answers.install, key: options.key || answers.key, name: selectedName.name, shortName: options.shortName || answers.shortName, templateName: selectedTemplate.template, reportIdProd: options.reportIdProd || answers.reportIdProd, reportIdTest: options.reportIdTest || answers.reportIdTest });
};
const initGit = async (options) => {
    const init = await execa('git', ['init'], {
        cwd: options.targetDirectory,
    });
    if (init.failed) {
        return Promise.reject(new Error('Failed to initialize git'));
    }
    const gitIgnorePath = path.join(options.targetDirectory || '', '/.gitignore');
    await fs.writeFile(gitIgnorePath, 'node_modules\r\n.fusion', (err) => {
        if (err) {
            return Promise.reject(new Error('Failed to create .gitignore file'));
        }
    });
    return;
};
const createAndSetTargetDir = (key) => {
    const newDir = './' + key;
    if (!fs.existsSync(newDir)) {
        fs.mkdirSync(newDir);
        return process.cwd() + '/' + key;
    }
    console.error('%s Target directory already exists, select a different app key', chalk.red.bold('ERROR'));
    process.exit(1);
};
const updatePackageConfig = async (options) => {
    const configPath = path.join(options.targetDirectory || '', '/package.json');
    try {
        await access(configPath, fs.constants.R_OK);
    }
    catch (err) {
        if (err instanceof Error) {
            console.error('%s Cant access new app config', chalk.red.bold('ERROR'));
            process.exit(1);
        }
        else {
            throw err;
        }
    }
    const config = JSON.parse(fs.readFileSync(configPath).toString());
    config.name = options.key;
    config.manifest.name = options.name;
    config.description = options.description;
    config.manifest.shortName = options.shortName;
    config.scripts = Object.assign({}, config.scripts);
    fs.writeFileSync(configPath, JSON.stringify(config, null, 4));
};
const copyTemplateFiles = async (options) => {
    const success = await copy(options.templateDirectory, options.targetDirectory, {
        clobber: false,
    });
    const indexJsPath = path.join(options.targetDirectory || '', 'src', 'index.tsx');
    const indexJsContent = fs.readFileSync(indexJsPath).toString();
    let indexJsContentReplaced = indexJsContent.replace('{appKey}', options.key || 'app-key');
    if (options.templateName === 'report') {
        indexJsContentReplaced = indexJsContentReplaced
            .replace('{REPORTIDPROD}', options.reportIdProd || 'ReportID Production placeholder')
            .replace('{REPORTIDTEST}', options.reportIdTest || 'ReportID Test placeholder');
    }
    fs.writeFileSync(indexJsPath, indexJsContentReplaced);
    return success;
};
const createProject = async (options) => {
    options = Object.assign(Object.assign({}, options), { targetDirectory: options.targetDirectory || createAndSetTargetDir(options.key || '') });
    const templateDir = path.resolve(__filename, `../../templates/${options.templateName}`);
    options.templateDirectory = templateDir;
    console.log(options.templateDirectory);
    try {
        await access(templateDir, fs.constants.R_OK);
    }
    catch (err) {
        if (err instanceof Error) {
            console.error('%s Invalid template name', chalk.red.bold('ERROR'));
            process.exit(1);
        }
        else {
            throw err;
        }
    }
    const tasks = new Listr([
        {
            task: () => copyTemplateFiles(options),
            title: 'Copy project files',
        },
        {
            enabled: () => (options.git ? true : false),
            task: () => initGit(options),
            title: 'Initialize git',
        },
        {
            task: () => updatePackageConfig(options),
            title: 'Update package config',
        },
        {
            skip: () => !options.install
                ? 'Pass --install to automatically install dependencies'
                : undefined,
            task: () => pkg_install_1.projectInstall({
                cwd: options.targetDirectory,
            }),
            title: 'Install dependencies',
        },
    ]);
    await tasks.run();
    console.log('%s App ready', chalk.green.bold('DONE'));
    return true;
};
//# sourceMappingURL=create-app.js.map
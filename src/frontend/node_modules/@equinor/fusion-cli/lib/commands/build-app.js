"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const Listr = require("listr");
const path = require("path");
const fs = require("fs");
const util = require("util");
const webpack = require("webpack");
const rimraf = require("rimraf");
const archiver = require("archiver");
const webpack_merge_1 = require("webpack-merge");
const babel_1 = require("../build/parts/babel");
const entry_1 = require("../build/parts/entry");
const images_1 = require("../build/parts/images");
const externals_1 = require("../build/parts/externals");
const styles_1 = require("../build/parts/styles");
const typescript_1 = require("../build/parts/typescript");
const output_1 = require("../build/parts/output");
const mode_1 = require("../build/parts/mode");
const env_1 = require("../build/parts/env");
const logSymbols = require("log-symbols");
const getPackageAsync_1 = require("../build/getPackageAsync");
const getPackageDependencies_1 = require("../build/getPackageDependencies");
// Promisify
const rimrafAsync = util.promisify(rimraf);
const statAsync = util.promisify(fs.stat);
const existsAsync = async (p) => {
    try {
        await statAsync(p);
        return true;
    }
    catch (e) {
        return false;
    }
};
const writeFileAsync = util.promisify(fs.writeFile);
const copyFileAsync = util.promisify(fs.copyFile);
const mkdirAsync = util.promisify(fs.mkdir);
class Timer {
    constructor() {
        this.start = new Date();
    }
    getEllapsedSeconds() {
        const end = new Date();
        return ((end.getTime() - this.start.getTime()) / 1000).toFixed(2) + ' seconds';
    }
}
class CompileError extends Error {
    constructor(errors) {
        super(errors.map(e => e.message).join('\n'));
        this.errors = errors;
    }
}
class BuildApp extends command_1.Command {
    async run() {
        const parsed = this.parse(BuildApp);
        await this.buildAppAsync(parsed.flags);
    }
    async buildAppAsync(options) {
        const timer = new Timer();
        const tasks = new Listr([
            {
                task: (ctx, task) => this.clearOutputDirAsync(ctx, task),
                title: 'Clean output dir',
            },
            {
                task: (ctx, task) => this.runBuildAsync(ctx, task),
                title: 'Build',
            },
            {
                skip: ctx => !ctx.buildSucceeded,
                task: (ctx, task) => this.writeManifestAsync(ctx, task),
                title: 'Generate manifest',
            },
            {
                skip: ctx => !ctx.buildSucceeded,
                task: (ctx, task) => this.copyResourcesAsync(ctx, task),
                title: 'Copy resources',
            },
            {
                enabled: () => options.zip,
                skip: ctx => !ctx.buildSucceeded,
                task: (ctx, task) => this.generateZipAsync(ctx, task),
                title: 'Generate zip',
            },
        ], {
            renderer: options.silent ? 'silent' : 'default',
        });
        const appPackage = await getPackageAsync_1.default(process.cwd());
        const manifest = await this.generateManifestAsync(appPackage);
        const outputDir = await this.getOutputDirAsync(options);
        const context = {
            appOutputDir: path.resolve(outputDir, appPackage.name),
            manifest,
            outputDir,
            package: appPackage,
        };
        try {
            await tasks.run(context);
            this.log(`${logSymbols.success} Built the ${manifest.name} app in ${timer.getEllapsedSeconds()}`);
        }
        catch (e) {
            if (e.errors) {
                e.errors.forEach(e => this.error(e.message));
            }
            this.log(`${logSymbols.error} Build failed after ${timer.getEllapsedSeconds()}`);
            // this.error(e);
            this.exit(1);
        }
    }
    async clearOutputDirAsync(context, task) {
        const timer = new Timer();
        task.output = 'Cleaning output dir';
        const outputDirExists = await existsAsync(context.outputDir);
        if (outputDirExists) {
            await rimrafAsync(context.outputDir);
        }
        task.title = 'Output dir cleaned in ' + timer.getEllapsedSeconds();
    }
    runBuildAsync(context, task) {
        return new Promise(async (resolve, reject) => {
            task.output = 'Configuring';
            const config = await this.createWebpackConfigAsync(context, task);
            const compiler = webpack(config);
            task.title = 'Building';
            compiler.run((err, stats) => {
                context.buildSucceeded = !err && stats && !stats.hasErrors();
                if (err) {
                    task.title = 'Build failed';
                    return reject(err);
                }
                if (stats && stats.hasErrors()) {
                    task.title = 'Build failed';
                    return reject(new CompileError(stats.compilation.errors));
                }
                const buildDuration = (stats && stats.endTime || 0) - (stats && stats.startTime || 0);
                task.title = `Build completed in ${(buildDuration / 1000).toFixed(2)} seconds`;
                resolve();
            });
        });
    }
    async generateManifestAsync(appPackage) {
        const manifest = appPackage.manifest;
        manifest.key = appPackage.name;
        manifest.main = appPackage.main;
        manifest.version = this.parsePackageVersion(appPackage);
        return manifest;
    }
    async writeManifestAsync(context, task) {
        const timer = new Timer();
        await writeFileAsync(path.resolve(context.appOutputDir, 'app-manifest.json'), JSON.stringify(context.manifest, null, 4));
        task.title = 'Manifest generated in ' + timer.getEllapsedSeconds();
    }
    async copyResourcesAsync(context, task) {
        const timer = new Timer();
        try {
            await this.copyResourceAsync(process.cwd(), context.appOutputDir, 'app-icon.svg', task);
        }
        catch (e) {
            this.log(`Unable to find SVG icon. [${e.message}]`);
        }
        if (context.manifest.resources) {
            const copyTasks = context.manifest.resources.map((resource) => this.copyResourceAsync(process.cwd(), context.appOutputDir, resource, task));
            await Promise.all(copyTasks);
        }
        task.title = 'Resources copied in ' + timer.getEllapsedSeconds();
    }
    async copyResourceAsync(sourcePath, destinationPath, resourceName, task) {
        task.output = `Copying ${resourceName}`;
        const from = path.resolve(sourcePath, resourceName);
        const sourceExists = await existsAsync(from);
        if (!sourceExists) {
            throw new Error(`Unable to find resource: ${resourceName} in ${from}`);
        }
        const to = path.resolve(destinationPath, resourceName);
        try {
            await mkdirAsync(path.dirname(to), { recursive: true });
        }
        catch (error) {
            if (error.code !== 'EEXIST') {
                throw error;
            }
        }
        await copyFileAsync(from, to);
    }
    async generateZipAsync(context, task) {
        const timer = new Timer();
        const outputStream = fs.createWriteStream(path.join(context.outputDir, context.manifest.key + '.zip'));
        const archive = archiver('zip', {
            zlib: { level: 9 },
        });
        archive.directory(context.appOutputDir, false);
        archive.pipe(outputStream);
        await archive.finalize();
        task.title = 'Zip generated in ' + timer.getEllapsedSeconds();
    }
    async createWebpackConfigAsync(context, task) {
        const fusionCliPackage = await getPackageAsync_1.default(path.resolve(__dirname, '..', '..'));
        const cliDependencies = await getPackageDependencies_1.default(fusionCliPackage);
        const moduleDependencies = await getPackageDependencies_1.default(context.package);
        const progressHandler = (percentage, msg, moduleProgress) => {
            const percentageString = Math.ceil(percentage * 100).toString();
            const messages = ['[webpack]', msg, moduleProgress];
            task.output = messages.filter(m => m).join(' ');
            task.title = `Building (${percentageString}%)`;
        };
        const appWebpackConfig = require(path.resolve(process.cwd(), 'webpack.config.js'));
        return webpack_merge_1.merge(babel_1.default, mode_1.default(true), entry_1.default(context.package, true), images_1.default(`/bundles/apps/${context.manifest.key}/resources/`), externals_1.default(cliDependencies, moduleDependencies), styles_1.default, typescript_1.default(context.appOutputDir, true), output_1.default('app-bundle.js', context.appOutputDir), {
            plugins: [new webpack.ProgressPlugin(progressHandler)],
        }, env_1.default(), appWebpackConfig);
    }
    async getOutputDirAsync(options) {
        return path.resolve(process.cwd(), options.out || '/out');
    }
    parsePackageVersion(appPackage) {
        const parts = appPackage.version.split('.');
        return {
            major: parts[0],
            minor: parts[1],
            patch: parts[2],
        };
    }
}
exports.default = BuildApp;
BuildApp.description = 'Build the app as a ready-to-deply zip bundle';
BuildApp.flags = {
    // help: flags.help({char: 'h'}),
    out: command_1.flags.string({ char: 'o', description: 'Output path', default: './out' }),
    silent: command_1.flags.boolean({ char: 's', description: 'No console output', default: false }),
    zip: command_1.flags.boolean({
        allowNo: true,
        char: 'z',
        default: true,
        description: 'Generate zip',
    }),
};
//# sourceMappingURL=build-app.js.map
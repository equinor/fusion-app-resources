import { useFusionContext } from '../core/FusionContext';
import { useCallback, useEffect, useState } from 'react';
/**
 * Fetch config for the app stored in the portal.
 * The config can be updated by pushing to the config endpoint. /api/apps/{app-key}/config.
 *
 * Configs support pushing special configs to a tag. This config will live independently from the default config.
 * This can be used if introducing breaking changes.
 * The pipeline can push two configs, ex. default & v2.0. The app can then call the hook with useAppConfig("v2.0").
 * This will allow existing published apps to still use the default config, while the preview version can use the v2.0.
 * Default can be overridden when all versions are using the v2.0, and 2.0 can be deleted
 *
 * Config is returned as a Partial<TConfig>. This is to remind the consumer that the object returned from the API is not guaranteed to honor the specified ts type.
 * All nested config types should also think of the same issue, however this is not enforced by the framework.
 *
 * @param tag The tag for the config version, defaults to null (main config)
 * @returns App config element
 */
export const useAppConfig = (tag) => {
    const fusion = useFusionContext();
    const [config, setConfig] = useState(null);
    const [isFetching, setIsFetching] = useState(false);
    const [error, setError] = useState(null);
    const fetchConfigAsync = useCallback(async (tag, cancellationToken) => {
        var _a;
        setIsFetching(true);
        setError(null);
        try {
            // Using the fusion context as a repository for configs, so we can cache values between usage.
            const config = await fusion.app.container.getConfigAsync(tag, cancellationToken);
            // Model should be safe to just cast. If the api model from the app container changes we might have to transform
            setConfig(config);
        }
        catch (err) {
            // Track error
            fusion.logging.telemetry.trackException({ exception: err });
            fusion.logging.telemetry.trackTrace({
                message: `Could not load config for app ${(_a = fusion.app.container.currentApp) === null || _a === void 0 ? void 0 : _a.key} @ tag ${tag}: ${err.message}`,
            });
            setConfig(null);
            setError(err);
        }
        finally {
            setIsFetching(false);
        }
    }, [fusion.app.container, fusion.logging.telemetry]);
    useEffect(() => {
        const cancellationSource = new AbortController();
        fetchConfigAsync(tag, cancellationSource.signal);
        return () => {
            cancellationSource.abort();
        };
    }, [tag, fusion.app.container, fetchConfigAsync]);
    return {
        isFetching: isFetching,
        tag,
        value: config,
        error,
    };
};
export default useAppConfig;

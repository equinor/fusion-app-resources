import ApiClients from '../http/apiClients';
import { Context, ContextTypes } from '../http/apiClients/models/context';
import ReliableDictionary from '../utils/ReliableDictionary';
import AppContainer from '../app/AppContainer';
import { History } from 'history';
import FeatureLogger from '../utils/FeatureLogger';
import { TelemetryLogger } from '../utils/telemetry';
declare type ContextCache = {
    current: Context | null;
    history: Context[] | null;
    links: {
        [key: string]: string;
    };
};
export default class ContextManager extends ReliableDictionary<ContextCache> {
    private appContainer;
    private featureLogger;
    private telemetryLogger;
    private history;
    private readonly contextClient;
    private isSettingFromRoute;
    constructor(apiClients: ApiClients, appContainer: AppContainer, featureLogger: FeatureLogger, telemetryLogger: TelemetryLogger, history: History);
    private appHasContext;
    private getAppPath;
    private urlHasPath;
    private getScopedPath;
    private buildUrlWithContext;
    private ensureCurrentContextExistsInUrl;
    private resolveContextFromUrlOrLocalStorageAsync;
    private validateContext;
    setCurrentContextAsync(context: Context | null): Promise<void>;
    setCurrentContextIdAsync(id: string | null): Promise<void>;
    private updateHistoryAsync;
    private updateLinksAsync;
    getLinkedContextAsync(context: Context): Promise<Context | null>;
    getCurrentContext(): Context | null;
    getHistory(): Context[];
    getCurrentContextAsync(): Promise<Context | null>;
    exchangeContextAsync(currentContext: Context, ...requiredTypes: ContextTypes[]): Promise<Context[]>;
    exchangeCurrentContextAsync(...requiredType: ContextTypes[]): Promise<Context[]>;
    private setCurrentContextFromIdAsync;
}
declare const useContextManager: () => ContextManager;
declare const useCurrentContextTypes: () => ContextTypes[];
declare const useContextHistory: () => Context[];
declare const useCurrentContext: () => Context | null;
declare const useContextQuery: () => {
    error: Error | null;
    isQuerying: boolean;
    contexts: Context[];
    search: (query: string) => void;
};
export { useContextManager, useCurrentContext, useContextQuery, useCurrentContextTypes, useContextHistory, };

import { v4 as uuidv4 } from 'uuid';
import DistributedState from './DistributedState';
import { useFusionContext } from '../core/FusionContext';
import fusionConsole from './fusionConsole';
const getSessionId = () => {
    const FUSION_SESSION_ID = 'FUSION_SESSION_ID';
    const existingSessionId = sessionStorage.getItem(FUSION_SESSION_ID);
    if (existingSessionId) {
        return existingSessionId;
    }
    const newSessionId = uuidv4();
    sessionStorage.setItem(FUSION_SESSION_ID, newSessionId);
    return newSessionId;
};
export default class FeatureLogger {
    constructor(apiClients, eventHub) {
        this.apiClients = apiClients;
        this.sessionId = getSessionId();
        this.logEntries = [];
        this.timer = null;
        this.isSendingBatch = false;
        this.currentAppKey = new DistributedState('FeatureLogger.currentAppKey', null, eventHub);
        this.currentContext = new DistributedState('FeatureLogger.currentContext', null, eventHub);
        this.transformers = new DistributedState('FeatureLogger.transformers', [
            (entry) => this.addAppToLogEntry(entry),
            (entry) => this.addContextToLogEntry(entry),
            (entry) => this.addScreenToLogEntry(entry),
        ], eventHub);
    }
    log(feature, featureVersion, payload) {
        const entry = this.transformLogEntry({
            feature,
            featureVersion,
            payload,
            dateTimeUtc: new Date(),
            metadata: {},
            url: window.location.href,
        });
        this.logEntries = [...this.logEntries, entry];
        this.scheduleBatch();
    }
    addTransformer(transformer) {
        this.transformers.state = [...this.transformers.state, transformer];
    }
    setCurrentApp(appKey) {
        this.currentAppKey.state = appKey;
    }
    setCurrentContext(id, name) {
        if (id === null || name === null) {
            this.currentContext.state = null;
        }
        else {
            this.currentContext.state = { id, name };
        }
    }
    scheduleBatch() {
        if (this.timer) {
            clearTimeout(this.timer);
        }
        if (this.logEntries.length >= 10) {
            this.sendBatchAsync();
            return;
        }
        this.timer = setTimeout(() => {
            this.sendBatchAsync();
        }, 5000);
    }
    async sendBatchAsync() {
        if (this.logEntries.length === 0) {
            return;
        }
        if (this.isSendingBatch) {
            return this.scheduleBatch();
        }
        this.isSendingBatch = true;
        const entries = this.logEntries.map((entry) => (Object.assign(Object.assign({}, entry), { appKey: entry.appKey || null, contextId: entry.contextId || null, contextName: entry.contextName || null, dateTimeUtc: entry.dateTimeUtc.toISOString(), payload: JSON.stringify(entry.payload), metadata: JSON.stringify(entry.metadata) })));
        const batch = {
            sessionId: this.sessionId,
            entries,
        };
        try {
            await this.apiClients.fusion.logFeaturesAsync(batch);
            this.logEntries = [];
            this.isSendingBatch = false;
            this.scheduleBatch();
        }
        catch (e) {
            fusionConsole.error(e);
            this.isSendingBatch = false;
        }
    }
    transformLogEntry(entry) {
        return this.transformers.state.reduce((entry, transformer) => transformer(entry), entry);
    }
    addAppToLogEntry(entry) {
        return Object.assign(Object.assign({}, entry), { appKey: this.currentAppKey.state });
    }
    addContextToLogEntry(entry) {
        var _a, _b;
        return Object.assign(Object.assign({}, entry), { contextId: (_a = this.currentContext.state) === null || _a === void 0 ? void 0 : _a.id, contextName: (_b = this.currentContext.state) === null || _b === void 0 ? void 0 : _b.name });
    }
    addScreenToLogEntry(entry) {
        try {
            const screen = {
                availableWidth: window.screen.availWidth,
                availableHeight: window.screen.availHeight,
                width: window.innerWidth,
                height: window.innerHeight,
                orientation: 'orientation' in window.screen && window.screen.orientation
                    ? window.screen.orientation.type
                    : 'unknown',
            };
            return Object.assign(Object.assign({}, entry), { metadata: Object.assign(Object.assign({}, entry.metadata), { screen }) });
        }
        catch (e) {
            fusionConsole.error(e);
        }
        return entry;
    }
}
export const useFeatureLogger = () => {
    const { logging: { feature }, } = useFusionContext();
    return feature;
};

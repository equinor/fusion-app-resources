import { useFusionContext } from '../core/FusionContext';
import DistributedState from './DistributedState';
import EventEmitter from './EventEmitter';
export default class AbortControllerManager extends EventEmitter {
    constructor(eventHub) {
        super();
        this.currentAbortController = new DistributedState('CurrentAbortController', null, eventHub);
        this.currentAbortController.on('change', (abortController) => {
            this.emit('update', abortController);
        });
    }
    withAbortController(abortableAction) {
        const abortController = new AbortController();
        this.currentAbortController.state = abortController;
        abortableAction(abortController.signal).then(() => {
            this.currentAbortController.state = null;
        });
        return () => abortController.abort();
    }
    getCurrentSignal() {
        if (this.currentAbortController.state === null) {
            return null;
        }
        return this.currentAbortController.state.signal;
    }
}
const useAbortControllerManager = () => {
    const { abortControllerManager } = useFusionContext();
    return abortControllerManager;
};
/**
 * Returns a function to be called if the request(s) performed within the passed function should be aborted
 */
const withAbortController = () => {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const abortControllerManager = useAbortControllerManager();
    return (abortableAction) => {
        return abortControllerManager.withAbortController(abortableAction);
    };
};
/**
 * Enqueue an operation to be run after the next repaint
 * @param operation
 * @param abortSignal
 */
const enqueueAsyncOperation = (operation, abortSignal) => {
    return new Promise((resolve, reject) => {
        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
            return reject();
        }
        window.requestAnimationFrame(() => {
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                return reject();
            }
            setTimeout(async () => {
                if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                    return reject();
                }
                try {
                    const result = operation();
                    resolve(result);
                }
                catch (e) {
                    reject(e);
                }
            }, 0);
        });
    });
};
export { useAbortControllerManager, withAbortController, enqueueAsyncOperation, };

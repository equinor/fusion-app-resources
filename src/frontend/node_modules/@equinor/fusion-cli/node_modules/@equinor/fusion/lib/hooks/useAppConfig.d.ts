/**
 * Public facing model for config.
 */
export declare type AppEnvironmentConfig<TConfig> = {
    environment: Partial<TConfig>;
    endpoints: {
        [key: string]: string;
    };
};
/**
 * Configuration for an app.
 * The fetching prop will indicate that the config is loading from the api.
 * Tag is populated with whichever tag is requested from the hook.
 */
declare type AppConfig<T> = {
    isFetching: boolean;
    value: AppEnvironmentConfig<T> | null;
    tag?: string | null;
    error?: Error | null;
};
/**
 * Fetch config for the app stored in the portal.
 * The config can be updated by pushing to the config endpoint. /api/apps/{app-key}/config.
 *
 * Configs support pushing special configs to a tag. This config will live independently from the default config.
 * This can be used if introducing breaking changes.
 * The pipeline can push two configs, ex. default & v2.0. The app can then call the hook with useAppConfig("v2.0").
 * This will allow existing published apps to still use the default config, while the preview version can use the v2.0.
 * Default can be overridden when all versions are using the v2.0, and 2.0 can be deleted
 *
 * Config is returned as a Partial<TConfig>. This is to remind the consumer that the object returned from the API is not guaranteed to honor the specified ts type.
 * All nested config types should also think of the same issue, however this is not enforced by the framework.
 *
 * @param tag The tag for the config version, defaults to null (main config)
 * @returns App config element
 */
export declare const useAppConfig: <T>(tag?: string | null | undefined) => AppConfig<T>;
export default useAppConfig;

import { __awaiter, __rest } from "tslib";
import { createPopper } from '@popperjs/core';
import { AttributePart, directive, PropertyPart } from 'lit-html';
const instances = new WeakMap();
export const popperjs = directive((popper, options) => (part) => __awaiter(void 0, void 0, void 0, function* () {
    if (!(part instanceof AttributePart) ||
        part instanceof PropertyPart ||
        part.committer.name !== 'popperjs' ||
        part.committer.parts.length > 1) {
        throw new Error('The `popperjs` directive must be used in the popperjs attribute and must be the only part in the attribute.');
    }
    const reference = part.committer.element;
    const target = yield Promise.resolve(popper);
    const _a = options || {}, { enabled } = _a, popperArgs = __rest(_a, ["enabled"]);
    if (enabled) {
        if (!instances.has(reference)) {
            const instance = createPopper(reference, target, popperArgs);
            // request update of posistion when size of reference or target changes
            instance.resizeObserver = new ResizeObserver(() => instance.update());
            instance.resizeObserver.observe(reference);
            instance.resizeObserver.observe(target);
            instances.set(reference, instance);
        }
        const instance = instances.get(reference);
        // TODO: options are mutable and will always hit.
        if (instance && popperArgs && instance.state.options !== popperArgs) {
            instance.setOptions(popperArgs);
        }
        // disabled, remove instance and clean up
    }
    else {
        const instance = instances.get(reference);
        instance === null || instance === void 0 ? void 0 : instance.destroy();
        instance === null || instance === void 0 ? void 0 : instance.resizeObserver.disconnect();
        instances.delete(reference);
    }
}));
export default popperjs;
//# sourceMappingURL=popperjs.js.map